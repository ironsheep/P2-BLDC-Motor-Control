'******************************************************************************
'*                                                                            *
'*    VGA/DVI/TV graphics and text mode video driver for Propeller2           *
'*   ===============================================================          *
'*                                                                            *
'*  This driver was inspired by original P2 video test code from Chip Gracey. *
'*  Since then it has expanded with many display and output features provided *
'*  below.  Thanks also for some assistance & suggestions from Parallax forum *
'*  members who helped find optimizations allowing performance improvements.  *
'*                                                                            *
'*  Features:                                                                 *
'*                                                                            *
'*    - single cog implementation                                             *
'*    - fully programmable output resolution and timing                       *
'*    - selectable DVI/VGA/SDTV/HDTV output mode and P2 pin group             *
'*    - multiple VGA sync options: RGBHV, RGBS, RGsB (SyncOnGreen) support    *
'*    - component HDTV video support up to 1080i (YPrPb)                      *
'*    - PAL or NTSC SDTV video over composite/S-video/component               *
'*    - interlaced or progressive scan outputs in video modes                 *
'*    - all P2 colour formats are supported in graphics modes                 *
'*    - built in 16 colour or mono text mode renderer                         *
'*    - programmable font size (1-256 scanlines), 8 pixel wide font           *
'*    - up to 240 text columns supported in 1920 pixel wide modes             *
'*    - optional text blinking attribute (VGA style 16 bit text data format)  *
'*    - interlaced text font output support                                   *
'*    - fine text scrolling capability                                        *
'*    - pixel width doubling, scanline doubling in all built in modes         *
'*    - dynamic colourspace converter parameters loaded per frame             *
'*    - multiple independently sized text or graphics regions per screen      *
'*    - a programmable mouse sprite available in all graphics/text regions    *
'*    - region specific mouse image data, palettes and/or fonts               *
'*    - selectable global mouse/region specific mouse co-ordinates            *
'*    - dual text cursors with independent attributes & colours per region    *
'*    - programmable top/bottom/side borders (per pixel boundary)             *
'*    - programmable border colour (24 bit)                                   *
'*    - programmable scanline source data skew/pitch                          *
'*    - screen source buffer wraparound options per region allowing scrolling *
'*    - per scanline status update for supporting external sprite drivers     *
'*    - support for odd/even field/frame automatic page flipping              *
'*    - software interface for requesting frame buffers from external memory  *
'*    - low system clock speeds supported using transparent pass through mode *
'*    - scalable performance, high clock cycle use features can be disabled   *
'*    - automatic PLL calculations for video timing                           *
'*                                                                            *
'*  Revision history:                                                         *
'*  -----------------                                                         *
'*   0.8b  21 NOV 2019   rogloh       -initial BETA release-                  *
'*   0.9b   1 JUL 2020   rogloh       minor bugfix to initial BETA release    *
'*   0.91b  2 JUL 2020   rogloh       second bugfix to initial BETA release   *
'*   0.92b 15 FEB 2021   rogloh       bugfix and text demo BETA release       *
'*                                                                            *
'******************************************************************************
{
LICENSE TERMS
-------------
Copyright 2019, 2020, 2021 Roger Loh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
}

CON

' clocks - customize the PLL values for different source crystal frequencies

    CLK350MHz   = %1_000011_0001000101_1111_10_11 '(20MHz/4) * 70/1 = 350   MHz
    CLK325MHz   = %1_000011_0001000000_1111_10_11 '(20MHz/4) * 65/1 = 325   MHz
    CLK315MHz   = %1_000011_0000111110_1111_10_11 '(20MHz/4) * 63/1 = 315   MHz
    CLK308MHz   = %1_000100_0001001100_1111_10_11 '(20MHz/5) * 77/1 = 308   MHz
    CLK297MHz   = %1_010011_0100101000_1111_10_11 '(20MHz/20)*297/1 = 297   MHz
    CLK270MHz   = %1_001001_0010000110_1111_10_11 '(20MHz/10)*135/1 = 270   MHz
    CLK252MHz   = %1_000100_0000111110_1111_10_11 '(20MHz/5) * 63/1 = 252   MHz
    CLK250MHz   = %1_000011_0000110001_1111_10_11 '(20MHz/4) * 50/1 = 250   MHz
    CLK240MHz   = %1_000100_0000111011_1111_10_11 '(20MHz/5) * 60/1 = 240   MHz
    CLK220MHz   = %1_000001_0000010101_1111_10_11 '(20MHz/2) * 22/1 = 220   MHz
    CLK216MHz   = %1_000100_0000110101_1111_10_11 '(20MHz/5) * 54/1 = 216   MHz
    CLK200MHz   = %1_000100_0000110001_1111_10_11 '(20MHz/5) * 50/1 = 200   MHz
    CLK148_5MHz = %1_100111_0100101000_1111_10_11 '(20MHz/40)*297/1 = 148.5 MHz
    CLK141_875MHz = %1_011111_0011100010_1111_10_11 '(20MHz/32)*227/1 = 141.875 MHz
    CLK135MHz   = %1_000011_0000011010_1111_10_11 '(20MHz/4) * 27/1 = 135   MHz
    CLK126MHz   = %1_010011_0001111101_1111_10_11 '(20MHz/20)*126/1 = 126   MHz
    CLK114_5MHz = %1_001010_0001111101_0000_10_11 '(20MHz/11)*126/2 = 114.5 MHz
    CLK108MHz   = %1_000100_0000011010_1111_10_11 '(20MHz/5) * 27/1 = 108   MHz
    CLK74_25MHz = %1_010011_0100101000_0001_10_11 '(20MHz/20)*297/4 = 74.25 MHz
    CLK65MHz    = %1_000100_0001000000_0001_10_11 '(20MHz/5) * 65/4 = 65    MHz
    CLK54MHz    = %1_000100_0000011010_0000_10_11 '(20MHz/5) * 27/2 = 54    MHz
    CLK50MHz    = %1_000011_0000100111_0001_10_11 '(20MHz/4) * 40/4 = 50    MHz
    CLK40MHz    = %1_000100_0000100111_0001_10_11 '(20MHz/5) * 40/4 = 40    MHz
    CLK27MHz    = %1_000100_0000011010_0001_10_11 '(20MHz/5) * 27/4 = 27    MHz
    CLK25_2MHz  = %1_000100_0000111110_0100_10_11 '(20MHz/5) * 63/10= 25.2  MHz


' clock source used below
    #0, CLKSRC_XTAL, CLKSRC_XIN

' setup one of these based on your P2 HW input clock,
' this will only be used if the PLL settings get automatically computed (see code below)
    'CLKIN_HZ = _xtalfreq ' also only enable CLKSRC_XTAL below as CLKSRC
    'CLKIN_HZ = _xinfreq  ' also only enable CLKSRC_XIN below as CLKSRC
    CLKIN_HZ = 20000000 ' assume 20MHz crystal by default

    CLKSRC = CLKSRC_XTAL ' enable this for crystal clock source (default)
    'CLKSRC = CLKSRC_XIN ' enable this for direct input clock source on XI (no crystal)

' parameters used when automatically determining PLL settings
    TOLERANCE_HZ = 500000    ' pixel clock accuracy will be constrained by this when no exact ratios are found
    MAXVCO_HZ    = 350000000 ' for safety, but you could try to overclock even higher at your own risk
    MINVCO_HZ    = 100000000
    MINPLLIN_HZ  = 500000    ' setting lower can find more PLL ratios but may begin to introduce more PLL jitter

' sync polarities
    SYNC_POS = 1
    SYNC_NEG = 0

' video modes
    #-1, TEXT, LUT1, LUT2, LUT4, LUT8, RGBI, RGB8, RGB16, RGB24, LUMA_ORANGE, LUMA_BLUE, LUMA_GREEN, LUMA_CYAN, LUMA_RED, LUMA_MAGENTA, LUMA_YELLOW, LUMA_WHITE

' video output types
    #0, VGA, DVI, CVBS, SVIDEO, SVIDEO_CVBS, COMPONENT_SDTV, COMPONENT_HDTV

' resolution
    #0, RES_640x350, RES_640x480, RES_800x480_DVI, RES_800x600, RES_800x600_DVI, RES_1024x768, RES_1280x1024, RES_1600x1200, RES_1920x1080, RES_1920x1200

' VGA output flags
    #0, RGBHV, RGBS, RGB_SOG 'SOG = sync on green

' TV output flags
    PROGRESSIVE = 0
    INTERLACED  = 1
    NTSC        = 0
    PAL         = 2

' DVI output flags
    DVI_NORMAL   = 0
    DVI_REVERSED = 1

' startup flags
    FORCE_MONO_TEXT= (1<<20)
    WAIT_ATN_START = (1<<21)

' region flags
    FLASH_TEXT     = 1
    GRAPHICS_MODE  = 2
    DOUBLE_WIDE    = 4
    DOUBLE_HIGH    = 8
    INTERLACED_SRC = 16
    TRANSPARENT_SRC= 32
    MOUSE_REGION   = 64
    MOUSE_ENABLE   = 128

' cursor flags
    CURS_PHASE1  = 0
    CURS_PHASE2  = 16
    CURS_TOPDOWN = 32
    CURS_SOLID   = 64
    CURS_ENABLE  = 128

' blanking state
    VBI_VSYNC = $80
    VBI_FP    = $40
    VBI_BP    = $20

' sizes of structures for client to maintain (in bytes)
    REGION_SIZE  = 48
    DISPLAY_SIZE = 56
    CONTEXT_SIZE = 16
    TIMING_SIZE  = 28

' colourspace & modulator levels (still work in progress)
    SAT = 70
    SCALE = 60
    TVMOD = SAT*1000/1646
    PALU = 492
    PALV = 877

    BLANK_LEVEL = 76

    CY_VGA = $5A000000 + BLANK_LEVEL
    CI_VGA = $005A0000 + BLANK_LEVEL
    CQ_VGA = $00005A00 + BLANK_LEVEL

    CI_COMP_SDTV = (( 64*SAT/100) & $ff) << 24 + ((-53*SAT/100) & $ff) << 16 + ((-10*SAT/100) & $ff) << 8 + 128
    CY_COMP_SDTV = 27 << 24 + 53 << 16 + 10 << 8 + BLANK_LEVEL
    CQ_COMP_SDTV = ((-22*SAT/100) & $ff) << 24 + ((-42*SAT/100) & $ff) << 16 + (( 64*SAT/100) & $ff) << 8 + 128

    CI_COMP_HDTV = ((+64*SCALE/128) & $FF) << 24 + ((-58*SCALE/128) & $FF) << 16 + (( -6*SCALE/128) & $FF) << 8 + 128
    CY_COMP_HDTV = ((+27*SCALE/128) & $FF) << 24 + ((+92*SCALE/128) & $FF) << 16 + (( +9*SCALE/128) & $FF) << 8 + 80
    CQ_COMP_HDTV = ((-15*SCALE/128) & $FF) << 24 + ((-49*SCALE/128) & $FF) << 16 + ((+64*SCALE/128) & $FF) << 8 + 128

    CY_CVBS_SDTV = ((+38*SAT/128) & $FF) << 24 + ((+75*SAT/128) & $FF) << 16 + ((+15*SAT/128) & $FF) << 8 + (110*SAT/128 & $FF)
    CI_CVBS_SDTV = ((+76*TVMOD/128) & $FF) << 24 + ((-35*TVMOD/128) & $FF) << 16 + ((-41*TVMOD/128) & $FF) << 8 + (100*SAT/128 & $FF)
    CQ_CVBS_SDTV = ((+27*TVMOD/128) & $FF) << 24 + ((-67*TVMOD/128) & $FF) << 16 + ((+40*TVMOD/128) & $FF) << 8 + 128

    CY_PAL = ((38*SAT/128) & $ff) << 24 + ((75*SAT/128) & $ff)<< 16 + ((15*SAT/128) & $ff) << 8 + BLANK_LEVEL
    CU_PAL =  ((-38*TVMOD*PALU/(128*1000)) & $FF) << 24 + ((-75*TVMOD*PALU/(128*1000)) & $FF) << 16 + ((117*TVMOD*PALU/(128*1000)) & $FF) << 8 + BLANK_LEVEL
    CV_PAL_ODD = ((89*TVMOD*PALV/(128*1000)) & $FF) << 24 + ((-75*TVMOD*PALV/(128*1000)) & $FF) << 16 + ((-15*TVMOD*PALV/(128*1000)) & $FF) << 8 + 128
    CV_PAL_EVEN = ((-89*TVMOD*PALV/(128*1000)) & $FF) << 24 + ((75*TVMOD*PALV/(128*1000)) & $FF) << 16 + ((15*TVMOD*PALV/(128*1000)) & $FF) << 8 + 128

'    COLOUR_BURST = $ADD60001
'    COLOUR_BURST = $4DFF0001
    COLOUR_BURST_NTSC = $50700001
    COLOUR_BURST_PAL  = $FF940001

    MAXCOGS = 8
'----------------------------------------------------------------------------------

DAT
context long  0[MAXCOGS] ' the printing context pointer per COG

'----------------------------------------------------------------------------------
' initialization methods
'----------------------------------------------------------------------------------

'initDisplay spawns driver COG returns cogid, display starts up blank until a region is attached
'cog - id of COG to use for driver (-1 to auto-allocate)
'display - indicates address of where display data is to be stored
'output - indicates type of output - VGA, DVI, COMPONENT_HDTV etc
'basePin - pin number of starting pin or group of pins
'syncPin - used for vertical sync output in VGA RGBHV mode
'flags - indicates if interlaced/progessive, PAL/NTSC, forced mono text etc
'lineBuf - hub address of two scanline working buffer
'maxLineSize - size of each scanline in the line buffer
'userTiming - when non-zero points to timing structure to be used to setup display
'mbox - pointer to start of external memort driver mailboxes
'firstRegion - points to first region in display list (or 0 if no regions yet)

PUB initDisplay(cog, display, output, basePin, syncPin, flags, lineBuf, maxLineSize, userTiming, mbox, firstRegion) : id | syncFlags, pin, timing, newfreq, newmode
    pin := basePin/4 & $f ' get 4 pin group start
    if output == VGA
        syncFlags := %0_0_000000
        if flags & 3 == RGBHV ' 5 pin VGA
            syncFlags |= syncPin & $3f
        if flags & 3 == RGBS ' 4 pin VGA
            syncFlags |= pin*4
        if flags & 3 == RGB_SOG ' 3 pin VGA
            syncFlags |= pin*4 + 2 ' sync on green
        timing := @vga_timing ' default to 640x480
    elseif output == DVI
        syncFlags := %1_0000000
        pin := basePin/8
        if flags & DVI_REVERSED
            pin |= 8
        timing := @dvi_timing ' default to 640x480
    else
        syncFlags := %0_1_000000
        if output == COMPONENT_HDTV
            syncFlags |= %0_0_100010
            if flags & INTERLACED <> 0
                syncFlags |= %0_0_010000
                timing := @hdint_timing ' 1080i60 default, TODO add 50Hz variant
            else
                if flags & PAL
                    timing := @hd50_timing '720p50
                else
                    timing := @hd60_timing '720p60
        else
            if output == COMPONENT_SDTV
                syncFlags |= %0_0_000111
            elseif output == CVBS
                syncFlags |= basePin & 3
            elseif output == SVIDEO
                syncFlags |= %0_0_000100
            elseif output == SVIDEO_CVBS
                syncFlags |= %0_0_000101

            if flags & INTERLACED <> 0
                syncFlags |= %0_0_010000
                if flags & PAL <> 0
                    syncFlags |= %0_0_001000
                    timing := @int576_timing
                else
                    timing := @int480_timing
            else ' progressive
                if output == COMPONENT_SDTV
                    if flags & PAL <> 0
                        syncFlags |= %0_0_001000
                        timing := @prog576_timing
                    else
                        timing := @prog480_timing
                else ' CVBS/S-video
                    if flags & PAL <> 0
                        syncFlags |= %0_0_001000
                        timing := @prog288_timing
                    else
                        timing := @prog240_timing

    ' override with custom timing if specified
    if userTiming <> 0
        timing := userTiming

    ' Optional PLL adjustment logic:
    ' This code attempts to be flexible in that you can choose to have this driver setup the P2 PLL
    ' for the pixel frequency setup and optional clock mode indicated in the timing structure,
    ' or leave the clock alone and have it configured elsewhere.
    '
    ' Two longs are part of the timing structure: the new optional clock mode, and the new P2 frequency.
    ' These are used to determine what to do and one of these three cases will be handled:
    '
    ' (a) If the new P2 frequency is 0 or equal to the current P2 clock frequency nothing will be changed.
    '
    ' (b) If the new P2 frequency is non-zero and the clock mode is non-zero, then that clock mode and
    ' frequency will be used in a CLKSET operation called by this driver.
    '
    ' (c) If the new P2 frequency is non-zero and the clock mode is 0, an attempt is made to auto-configure
    ' the PLL based on the specified new frequency.  The crystal or input clock frequency are required to
    ' be specified as well as the tolerance in Hz.  The closest PLL settings are computed based on these
    ' criteria and will be used in CLKSET.  If the tolerance is not met then no PLL timing will be changed.
    ' Take that into consideration when setting up the tolerance and don't set values that are unachievable.

    newmode := long[timing][0] ' get new clock mode
    newfreq := long[timing][1] ' get desired frequency
    if newfreq and (clkfreq <> newfreq)
        if newmode == 0
            newmode := computeClockMode(newfreq)
        if newmode
            CLKSET(newmode, newfreq)

    long[display][1] := (syncFlags << 24) + (pin << 20) + timing
    long[display][2] := 0 'reserved
    if mbox
        long[display][3] := (mbox & $fffff) | $0C00_0000  'external memory is supported
    else
        long[display][3] := 0 ' no external memory
    long[display][4] := lineBuf
    long[display][5] := lineBuf + maxLineSize
    long[display][6] := 0 'reserved
    long[display][7] := -1 ' global mouse offscreen
    long[display][8] := 0 ' no borders
    long[display][9] := 0 ' border colour (black)
    long[display][10] := firstRegion ' first region if non-zero
    if output == VGA
        long[display][11] := CQ_VGA
        long[display][12] := CY_VGA
        long[display][13] := CI_VGA
    elseif output == COMPONENT_SDTV
        long[display][11]:= CQ_COMP_SDTV
        long[display][12]:= CI_COMP_SDTV
        long[display][13]:= CY_COMP_SDTV ' Y on green output
    elseif output == COMPONENT_HDTV
        long[display][11]:= CQ_COMP_HDTV
        long[display][12]:= CI_COMP_HDTV
        long[display][13]:= CY_COMP_HDTV ' Y on green output
    else ' assume SDTV
        if flags & PAL <> 0
            long[display][6]:= CV_PAL_EVEN ^ CV_PAL_ODD
            long[display][11]:= CV_PAL_EVEN
            long[display][12]:= CY_PAL
            long[display][13]:= CU_PAL
        else
            long[display][11]:= CQ_CVBS_SDTV
            long[display][12]:= CY_CVBS_SDTV
            long[display][13]:= CI_CVBS_SDTV
    if flags & FORCE_MONO_TEXT
        display |= FORCE_MONO_TEXT
    else
        display &= !FORCE_MONO_TEXT

    if flags & WAIT_ATN_START
        display |= WAIT_ATN_START
    else
        display &= !WAIT_ATN_START

    if cog +> MAXCOGS-1
        cog := 16

    return coginit(cog, @videodriver, display)


PRI computeClockMode(desiredHz) : mode | vco, finput, f, p, div, m, error, bestError
    bestError := -1
    repeat p from 0 to 30 step 2
        ' compute the ideal VCO frequency f at this value of P
        if p <> 0
            if desiredHz > MAXVCO_HZ/p ' test it like this to not overflow
                quit
            f := desiredHz * p
        else
            f := desiredHz
            if f > MAXVCO_HZ
                quit
        ' scan through D values, and find best M, retain best case
        repeat div from 1 to 64
            'compute the PLL input frequency from the crystal through the divider
            finput := CLKIN_HZ/div
            if finput < MINPLLIN_HZ ' input getting too low, and only gets lower so quit now
                quit

            ' determine M value needed for this ideal VCO frequency and input frequency
            m := f / finput

            ' check for the out of divider range case
            if m +> 1024
                quit

            ' zero is special and gets a second chance
            if m == 0
                m++

            ' compute the actual VCO frequency at this particular M, D setting
            vco := finput * m
            if vco +< MINVCO_HZ
                quit
            if vco +> MAXVCO_HZ
                next

            ' compute the error and check next higher M value if possible, it may be closer
            error := abs(f - vco)
            if m < 1024 and (vco + finput) +< MAXVCO_HZ
                if error > abs(f - (vco + finput))
                    error := abs(f - (vco + finput))
                    m++

            ' retain best allowed frequency error and divider bits found so far
            if error +< bestError and error +< TOLERANCE_HZ+1
                bestError := error
                mode := ((div-1) << 18) + ((m-1) << 8) + (((p/2 - 1) & $f) << 4)

            ' quit whenever perfect match found
            if bestError == 0
                quit

        if bestError == 0
            quit

    ' final clock mode format is this #%0000_000E_DDDD_DDMM_MMMM_MMMM_PPPP_CCSS
    if mode
        ' also set 15 or 30pF capacitor loading based on input crystal frequency
        mode |= (1<<24) ' enable PLL
        if (CLKSRC == CLKSRC_XTAL) ' enable oscillator and caps for crystal
            mode |= (CLKIN_HZ < 16000000) ? %1111 : %1011
        else
            mode |= %0111 ' don't enable oscillator



PUB initRegion(region, gfxMode, size, regionFlags, palette, fontBase, fontSize, screenBuf, nextRegion) : r
' sets up a region
' optionally links it to a next region if that argument is non-zero

    long[region][0]  := nextRegion
    if (gfxMode > -1)
        regionFlags := regionFlags | GRAPHICS_MODE
    long[region][1]  := (size << 16) + ((regionFlags & $ff) << 8) + (gfxMode & $f)
    long[region][2]  := screenBuf
    long[region][3]  := screenBuf ' no wrap set yet
    long[region][4]  := (((fontSize-1) & $ff) << 24) + fontBase
    long[region][5]  := palette
    long[region][6]  := 0 ' cursor 1 off until enabled
    long[region][7]  := 0 ' cursor 2 off until enabled
    long[region][8]  := -1 ' region mouse offscreen
    long[region][9]  := 0 ' mouse image
    long[region][10] := 0 ' no wrap
    long[region][11] := 0 ' no skew
    return region

PUB getTiming(resolution) : r
' returns pre-defined timings for common video resolutions
    if (resolution == RES_640x350)
        return @ega_timing
    if (resolution == RES_800x480_DVI)
        return @wvga_dvi_timing
    if (resolution == RES_800x600)
        return @svga_timing
    if (resolution == RES_800x600_DVI)
        return @svga_dvi_timing
    if (resolution == RES_1024x768)
        return @xga_timing
    if (resolution == RES_1280x1024)
        return @sxga_timing
    if (resolution == RES_1600x1200)
        return @uxga_timing
    if (resolution == RES_1920x1080)
        return @fullhd_timing
    if (resolution == RES_1920x1200)
        return @wuxga_timing
    return @vga_timing ' default to VGA resolution


PUB createCustomTiming(timing, custompll, p2freq, divisor, hsyncpol, hfp, hsyncpixels, hbp, hcolumns, vsyncpol, vfp, vsynclines, vbp, vislines, breeze, colburst, cfreq) : r
' creates a custom timing structure from input arguments and returns the address of this structure in HUBRAM
'
' Note: no parameter validation occurs at this time so be careful with the values passed.
'       Values that are outside operational ranges will likely result in an unstable display or non-visible display output by monitors
'
' Parameters:
'
' timing - address of where timing data will be constructed in HUB RAM
' custompll - specific P2 PLL settings to use (or 0 to automatically compute this, based on the p2freq argument alone)
' p2freq - the P2 clock frequency associated with the PLL settings (if 0, the PLL is left untouched and the P2 remains at its existing frequency)
' divisor - this is the pixel divisor or XFRQ value, where the pixel output rate = p2freq / divisor
'        Note 3 cases:
'        1. when this value is less than $100 it is treated as an integer divisor to compute the XFRQ value to use
'        2. when this value is between $100 and $FFFF it is treated as a fractional divisor
'               where the LSB is the fraction and the MSB is the integer to compute the XFRQ value to use
'               e.g. a divisor of 7.5 would be passed in as $780
'        3. when this value is above $FFFF it not the divisor but gets used directly as the XFRQ register value (for advanced case uses)
' hsyncpol    - set non-zero for positive horizontal sync polarity, or 0 for negative hsync        
' hfp         - number of horizontal front porch pixels per scan line
' hsyncpixels - number of horizontal sync pixels per scan line
' hbp         - number of horizontal back porch pixels per scan line
' hcolumns    - number of columns (8 pixels) per scan line
' vsyncpol    - set non-zero if positive vertical sync, or 0 for negative vsync        
' vfp         - number of vertical front porch scan lines per frame
' vsynclines  - number of vertical sync lines per frame
' vbp         - number of vertical back porch scan lines per frame
' vislines    - number of visible (active) lines displayed per frame
' breeze      - number of clocks for the breezeway (needed for NTSC/PAL SDTV output only)
' colburst    - number of clocks for the colour burst (needed for NTSC/PAL SDTV output only)
' cfreq       - CFRQ register manual control (needed for NTSC/PAL SDTV output only)
    long[timing][0]:=custompll
    long[timing][1]:=p2freq
    long[timing][2]:=(hsyncpol) ? $80000000 : 0
    long[timing][2]|=(hfp & $7f) << 24
    long[timing][2]|=(hsyncpixels & $ff) << 16
    long[timing][2]|=(hbp & $ff) << 8
    long[timing][2]|=(hcolumns & $ff)
    long[timing][3]:=(vsyncpol) ? $80000000 : 0
    long[timing][3]|=(vfp & $ff) << 23
    long[timing][3]|=(vsynclines & 7) << 20
    long[timing][3]|=(vbp & $1ff) << 11
    long[timing][3]|=(vislines & $7ff)
    long[timing][4]:=(divisor +< 256) ? (divisor << 8) : divisor
    long[timing][5]:=(breeze & $ff) << 24
    long[timing][5]|=(colburst & $ff) << 16
    long[timing][5]|=((hfp<<1) & $ff00)
    long[timing][5]|=((hsyncpixels >> 4) & $f0)
    long[timing][5]|=((hbp >> 8) & $f)
    long[timing][6]:=cfreq
    return timing

PUB shutdown(display) ' untested method
    cogstop(long[display][2]) ' use cogid from display structure

'----------------------------------------------------------------------------------
' video status methods
'----------------------------------------------------------------------------------

PUB getScanLine(display) : r
    return (long[display] & $ffff)

PUB getFieldCount(display) : r
    return byte[display][2]

PUB getBlankingState(display) : r
    return byte[display][3]

PUB waitForVsync(display)
    repeat until byte[display][3] & VBI_VSYNC == 0
    repeat until byte[display][3] & VBI_VSYNC <> 0

PUB waitForBlanking(display)
    repeat until byte[display][3] == 0
    repeat until byte[display][3] & VBI_FP <> 0

'----------------------------------------------------------------------------------
' general region configuration methods
'----------------------------------------------------------------------------------

PUB getRegion(display, regionOffset) : region
    region := 0
    if (display <> 0) ' get head of list
       region := long[display][10]
    repeat while regionOffset <> 0 AND region <> 0
       region := long[region][0] ' traverse linked list
       regionOffset--

PUB getNextRegion(region) : r
    if region <> 0
       return long[region][0] ' traverse list
    else
       return 0 ' no next region

PUB setFlags(region, flags)
    byte[region][5] := flags

PUB getFlags(region) : flags
    return byte[region][5]

PUB setSize(region, size)
    word[region][3] := size

PUB getSize(region) : r
    return word[region][3]

PUB setMode(region, mode)
    if (mode < 0) ' configure as text
        byte[region][5] &= !GRAPHICS_MODE
    else
        byte[region][4] := mode
        byte[region][5] |= GRAPHICS_MODE

PUB getMode(region) : mode
    if byte[region][5] & GRAPHICS_MODE
        return byte[region][4]
    else
        return -1 ' text mode (OR should I just return the colour mode???)

PUB setSource(region, buf)
    long[region][2] := buf

PUB getSource(region) : source
    return long[region][2]

PUB setWrapSource(region, buf)
    long[region][3] := buf

PUB getWrapSource(region) : wrapsource
    return long[region][3]

' alternate field/frame source address config
PUB setAltSource(region, buf)
    long[region][6] := buf

PUB getAltSource(region) : source
    return long[region][6]

' alternate field/frame source address config after wrap around
PUB setAltWrapSource(region, buf)
    long[region][7] := buf

PUB getAltWrapSource(region) : wrapsource
    return long[region][7]

PUB setWrap(region, firstwrap, rewrap)
    long[region][10] := (rewrap << 16) + firstwrap

PUB getWrap(region, firstwrap, rewrap) : r
    return long[region][10]

PUB setSkew(region, skewAmount)
    long[region][11] := skewAmount

PUB getSkew(region) : r
    return long[region][11]

PUB setFont(region, fontBase, fontsize)
    long[region][4] := ((fontsize-1) << 24) + (fontBase & $fffff)

PUB getFont(region) : r
    return long[region][4] & $fffff

PUB setPalette(region, palette)
    long[region][5] := palette

PUB setTextScanStart(region, startscan)
    word[region][21] := startscan

PUB setTextFlash(region, enable)
    if (enable)
        byte[region][5] |= FLASH_TEXT
    else
        byte[region][5] &= !FLASH_TEXT

PUB setDoubleWide(region, enable)
    if (enable)
        byte[region][5] |= DOUBLE_WIDE
    else
        byte[region][5] &= !DOUBLE_WIDE

PUB setDoubleHigh(region, enable)
    if (enable)
        byte[region][5] |= DOUBLE_HIGH
    else
        byte[region][5] &= !DOUBLE_HIGH

'----------------------------------------------------------------------------------
' text cursor related methods
'----------------------------------------------------------------------------------

PUB setCursor(region, cursid, rowpos, colpos, flags, colour) | val
    val := ((rowpos & $ff) << 24) + ((colpos & $ff) << 16) + ((flags & $ff) << 8) + ((colour & $f) << 4) + (colour & $f)
    if (cursid == 0) ' first cursor
        long[region][6] := val
    else ' second cursor
        long[region][7] := val

PUB showCursor(region, cursid)
    if (cursid == 0) ' first cursor
        byte[region][25] |= $80
    else ' second cursor
        byte[region][29] |= $80

PUB hideCursor(region, cursid)
    if (cursid == 0) ' first cursor
        byte[region][25] &= !$80
    else ' second cursor
        byte[region][29] &= !$80

PUB setCursorPos(region, cursid, rowpos, colpos)
    if (cursid == 0)
        word[region][13] := ((rowpos & $ff) << 8) + (colpos & $ff)
    else
        word[region][15] := ((rowpos & $ff) << 8) + (colpos & $ff)

PUB setCursorFlags(region, cursid, flags)
    if (cursid == 0)
        byte[region][25] := flags
    else
        byte[region][29] := flags

PUB getCursorPos(region, cursid) : r
    if (cursid == 0)
        return word[region][13]
    else
        return word[region][15]

PUB getCursorRow(region, cursid) : r
    if (cursId == 0)
        return byte[region][27]
    else
        return byte[region][31]

PUB getCursorCol(region, cursid) : r
    if (cursid == 0)
        return byte[region][26]
    else
        return byte[region][30]

PUB setCursorColour(region, cursid, colour) ' single colour cursor
    if (cursid == 0)
        byte[region][24] := (colour & $f) * $11
    else
        byte[region][28] := (colour & $f) * $11

PUB setCursorColours(region, cursid, colour1, colour2) ' twin colour cursor
    if (cursid == 0)
        byte[region][24] := (colour1 & $f) + (colour2 & $f) << 4
    else
        byte[region][28] := (colour1 & $f) + (colour2 & $f) << 4

PUB setCursorHeight(region, cursid, height) | flip
    if height > 15
        height := 15
    if height < -15
        height := -15
    if height < 0
        flip := CURS_TOPDOWN - height
    else
        flip := height
    if (cursid == 0)
        byte[region][25] &= !(CURS_TOPDOWN + $F)
        byte[region][25] |= flip
    else
        byte[region][29] &= !(CURS_TOPDOWN + $F)
        byte[region][29] |= flip

'----------------------------------------------------------------------------------
'  mouse related methods
'----------------------------------------------------------------------------------

PUB setRegionMouse(region, x, y)
    long[region][8] := (y << 16) + (x & $ffff)

PUB setGlobalMouse(display, x, y)
    long[display][7] := (y << 16) + (x & $ffff)

PUB setMouseImage(region, image, x, y)
    long[region][9] := ((y & $f) << 28) + ((x & $f) << 24) + image

PUB showMouse(region, regionMouse)
    if regionMouse
        byte[region][5] |= MOUSE_ENABLE + MOUSE_REGION
    else ' global
        byte[region][5] |= MOUSE_ENABLE

PUB hideMouse(region)
    byte[region][5] &= !MOUSE_ENABLE

'----------------------------------------------------------------------------------
'  overall display related methods
'----------------------------------------------------------------------------------

PUB linkRegion(region1, region2) ' link region 2 after region 1
    long[region2][0] := long[region1][0]
    long[region1][0] := region2

PUB setDisplayRegions(display, region)
    long[display][10] := region

PUB setDisplayBorderSizes(display, top, bottom, width)
    long[display][8] := top + (bottom << 16)
    byte[display][36] := width

PUB setDisplayBorderColour(display, rgb)
    long[display][9] := (rgb << 8) + byte[display][36]

PUB setYIQ(display, cyparam, ciparam, cqparam)
    long[display][11] := cqparam
    long[display][12] := ciparam
    long[display][13] := cyparam

'----------------------------------------------------------------------------------
' status/dimensioning related methods
'----------------------------------------------------------------------------------

PUB getActiveLines(display) : r
    return (long[long[display][1]][3] & $7ff)

PUB getActivePixels(display) : r
    return ((long[long[display][1]][2] & $ff) << 3)

PUB getCurrentRows(display, region) : r | height
    height := byte[region][19]+1
    if byte[region][5] & DOUBLE_HIGH
        height *= 2
    r := word[region][3]
    if r == 0
        r := findRegionSize(display, region)
    return (r + height - 1) / height ' round up

PUB getCurrentColumns(display, region) : r | size, width
    width := 8
    if byte[region][5] & DOUBLE_WIDE
        width *= 2
    return (getActivePixels(display) + width - 1) / width ' round up

PUB getFontHeight(region) : r
    return byte[region][19]+1

PUB getBitDepth(region) : r
    if byte[region][5] & GRAPHICS_MODE == 0
        return 4 ' or 1 for mono?
    case byte[region][4]
        0:  return 1
        1:  return 2
        2:  return 4
        6:  return 16
        7:  return 32
        OTHER:  return 8

'----------------------------------------------------------------------------------
'  text printing related methods
'----------------------------------------------------------------------------------

PUB out(char) | src, size, fontsize, rowpos, colpos, rows, columns, ctx, currpos, region, colours, cursid
    ' get printing context for this COG and check if it's been setup already
    if (ctx := context[cogid()]) == 0
        return

    ' text output is supported only in text regions in hub (for now)
    region := long[ctx][1]
    src := long[region][2]
    if (byte[region][5] & GRAPHICS_MODE <> 0) OR (src & $f0000000)
        return

    ' get current text position and colours
    currpos := word[ctx][4]  'current row, col position (read together atomically)
    rowpos := currpos >> 8   'extract row
    colpos := currpos & $ff  'and column
    colours := byte[ctx][10] 'extract text fg & bg colours
    cursid := byte[ctx][11]  'get optional HW cursor id to manage (0=none, or HW cursor 1, 2)

    ' compute total rows and columns from region settings & active pixel width
    fontsize := byte[region][19]+1
    if byte[region][5] & DOUBLE_HIGH
        fontsize *= 2
    ' start with number of scan lines in region
    rows := word[region][3]
    if rows == 0 ' region has been auto-sized to end of screen
        rows := findRegionSize(long[ctx][0], region)

    ' do no damage if region size was not found or height was somehow corrupted in memory
    if rows == 0 or fontsize == 0
        return

    ' divide scanlines by font size and round up to compute character rows
    rows := (rows + fontsize - 1) / fontsize

    ' compute columns
    columns := (byte[region][5] & DOUBLE_WIDE) ? 16 : 8
    columns := (word[ctx][6] + columns - 1) / columns ' round up
    ' ensure we can still write to the screen if the width or height changes dynamically
    if rowpos +>= rows
        rowpos := rows-1
    if colpos +>= columns
        colpos := columns - 1

    ' process char
    if char == 8  ' BACKSPACE
        if colpos
            colpos--
            word[src][rowpos * columns + colpos] := (colours << 8) + 32
    elseif char == 9 ' TAB
        if colpos < columns - 8
            colpos += 8 - (colpos & 7)
    elseif char == 13 ' CR
        byte[ctx][15] := colpos ' save this original CR position for LF use later
        colpos := 0
    elseif char == 12 ' FF
        clear()
        return
    else
        ' update the screen if a printable character
        if (char > 31)
            word[src][rowpos * columns + colpos] := (colours << 8) + (char & $ff)
            colpos++
        ' handle line wrap if required
        if colpos == columns OR char == 10
             ' if a LF before end of line is reached, also clear to end of line
             if (colpos < columns)
                if byte[ctx][14] == 13 ' if LF followed a CR, only clear from original CR position
                    colpos := byte[ctx][15]
                wordfill(src + (rowpos * columns + colpos) * 2, (colours << 8) + 32, columns - colpos)

            colpos := 0
            ' scroll the region if needed
            if ++rowpos == rows
                rowpos-- ' back up a row
                ' determine size of a row including any skew
                size := long[region][11]
                if size < 0 ' negative skews are incompatible with text scrolling and will be ignored
                    size := 0
                size += columns * 2

                ' scroll up
                bytemove(src, src + size, size * (rows - 1))
                ' clear bottom row
                wordfill(src + rowpos * columns * 2, (colours & $ff) << 8 + 32, size/2)

    ' if a HW cursor is applied to the text region, then also update its position
    if cursid
        setCursorPos(region, ((cursid & $f) - 1) & 1, rowpos, colpos)

    ' save last position and last char
    word[ctx][4] := (rowpos << 8) + (colpos & $ff)
    byte[ctx][14] := char


PUB printStr(str) : len
    repeat until byte[str][len] == 0
        out(byte[str][len++])

PUB nl() ' new line
    out(10)

PUB tx(ch)
    out(ch)

PUB txraw(ch) ' print from full character set, no BS/TAB/LF/FF/CR handling
    out((ch & $ff) | $100)

PUB tx16(ch) ' experimental 16 pixel characters
    'lower 128 chars of font contains left 8 pixels of a 16 pixel char
    'upper 128 chars of font contains right 8 pixels of a 16 pixel char
    if ch & 128 == 0' can only support 128 characters using this method
        if ch==8
            out(ch) ' output an extra backspaces
        out(ch)
        if ch > 31
            out(ch | $80)

PUB tx32(ch) ' experimental 32 pixel characters
    'lower 64 chars of font contains leftmost 8 pixels of a 32 pixel char
    'next 64 chars of font contains pixels 7-15
    'next 64 chars of font contains pixels 16-23
    'upper 64 chars of font contains rightmost 8 pixels of a 32 pixel char
    'this can only support 64 characters using this method (32-95)
    'you lose: lower case a-z ` { | } ~ DEL chars
    ch &= $7f
    if ch > 96
        ch-=32
    if ch < 96
        if ch==8
            repeat 3
                out(ch) ' output 3 extra backspaces
        if ch < 32 'control char
            out(ch)
        else 'printable
            ch:=ch - 32
            out($100+ch)
            out($140+ch)
            out($180+ch)
            out($1C0+ch)

PUB printStr16(str) : len
    repeat until byte[str][len] == 0
        tx16(byte[str][len++])

PUB printStr32(str) : len
    repeat until byte[str][len] == 0
        tx32(byte[str][len++])

PUB initTextOutput(ctx, display, region, fg, bg, hwcursor, clearscreen)
    ' init the text region's context data
    long[ctx][0] := display
    long[ctx][1] := region
    long[ctx][2] := ((hwcursor & $ff) << 24) + ((((bg & $f) << 4) | (fg & $f)) << 16)  ' home row,col to 0,0
    word[ctx][4] := 0
    word[ctx][6] := getActivePixels(display)
    word[ctx][7] := 0
    ' init the HW cursor if enabled, and optionally clear the screen
    if hwcursor
        setCursorPos(region, (hwcursor - 1) & 1, 0, 0)
    context[cogid()] := ctx
    if clearscreen
        clear()

PUB setTextOutput(ctx, singleCursor) | oldctx
    oldctx := context[cogid()]
    context[cogid()] := ctx
    ' if we want a single HW cursor only, have it follow the active text region
    if singleCursor
        if (oldctx <> 0) AND (byte[oldctx][11] <> 0)
            hideCursor(long[oldctx][1], (byte[oldctx][11]-1) & 1)
        if byte[ctx][11]
            showCursor(long[ctx][1], (byte[ctx][11]-1) & 1)

' get pointer to current text output context being used by COG
PUB getTextOutput() : ctx
    ctx := context[cogid()]

' clears text region
PUB clear() | ctx, region, display, cursid
    if (ctx := context[cogid()])
        display := long[ctx][0]
        region  := long[ctx][1]
        wordfill(getSource(region), (byte[ctx][10] << 8) + 32, getCurrentRows(display, region)*getCurrentColumns(display, region))
        word[ctx][4] := 0 ' home the row & column to 0
        cursid := byte[ctx][11]
        if cursid ' set HW cursor if enabled
            setCursorPos(region, (cursid - 1) & 1, 0, 0)

' sets colours or attributes of text
' colour text: fgcolour, bgcolour are colour indexes 0-F for foreground and background colours
' mono text: attributes fgcolour bit0 = INVERSE, bgcolour bit3 = FLASH
PUB setTextColours(fgcolour, bgcolour) | ctx
    if (ctx := context[cogid()])
        byte[ctx][10] := ((bgcolour & $f) << 4) | (fgcolour & $f)

PUB getTextColours() : fgcolour, bgcolour | ctx
    if (ctx := context[cogid()]) == 0
        return
    fgcolour := byte[ctx][10] & $f
    bgcolour := byte[ctx][10] >> 4

PUB setTextPos(curs_row, curs_col) | cursid, ctx
    if (ctx := context[cogid()])
        word[ctx][4] := ((curs_row & $ff) << 8) + (curs_col & $ff)
        cursid := byte[ctx][11]
        if cursid
            setCursorPos(long[ctx][1], (cursid - 1) & 1, curs_row, curs_col)

PUB getTextPos() : curs_row, curs_col | ctx
    if (ctx := context[cogid()]) == 0
        return
    curs_col := byte[ctx][8]
    curs_row := byte[ctx][9]

PRI findRegionSize(display, region) : size | ptr
    ptr := long[display][10]
    size := getActiveLines(display) - word[display][16]
    repeat while ptr <> 0 and ptr <> region and size > 0
        size -= word[ptr][3]
        ptr := long[ptr][0]
    if (ptr == region) and (size > 0)
        return
    return 0

PUB dec(value) | i, showzero
' Print a signed decimal number
  showzero := 0

  if value < 0
    value := -value
    tx("-")

  i := 1_000_000_000

  repeat 10
    if value >= i
      tx(value / i + "0")
      value //= i
      showzero := 1
    elseif showzero or i == 1
      tx("0")
    i /= 10


PUB hex(value, digits)
' Print a hexadecimal number
  value <<= (8 - digits) << 2
  repeat digits
    value ROL= 4
    tx(lookupz(value & $F : "0".."9", "A".."F"))


PUB bin(value, digits)
' Print a binary number
  value <<= 32 - digits
  repeat digits
    value ROL= 1
    tx((value & 1) + "0")

'----------------------------------------------------------------------------------

CON

    EXTMEMREQ = %1011 ' external memory burst read request

    ' default resolution timing parameters if not specified
    V_VISIBLE       = 480
    V_FP            = 10
    V_SYNC          = 2
    V_BP            = 33

    H_VISIBLE       = 640
    H_FP            = 16
    H_SYNC          = 96
    H_BP            = 48

    V_SYNC_POLARITY = SYNC_NEG
    H_SYNC_POLARITY = SYNC_NEG

    COLS            = (H_VISIBLE/8)


'------------------------------------------------------------------------------
DAT
            orgh

videodriver
            org 0

'--------------------------------------------------------------------------------------------------
'
' Initial driver entry code, this is also reused later for variable storage
'
'--------------------------------------------------------------------------------------------------
statusaddr                  mov     statusaddr, ptra        'save ptra as the status address
mailbox                     rdlong  mailbox, ptra[3]        'read mailbox address information
linebuf1                    rdlong  linebuf1, ptra[4]       'extract scan line buffer address
linebuf2                    rdlong  linebuf2, ptra[5]       'extract scan line buffer address
linebufsize                 add     ptra, #24               'skip past the init parameters
paramaddr                   mov     paramaddr, ptra         'save pointer to first region data
regn                        cogid   c                       'get our cog id
modedata                    getbyte b, mailbox, #3          'get per COG mailbox spacing in bytes
screenaddr1                 mov     a, b                    'duplicate for later
screenaddr2                 mul     b, #MAXCOGS wz          'multiply by total number of COGs
fontaddr                    sub     mailbox, b              'subtract so instances start from 1
paletteaddr                 mul     a, c                    'compute offset for this COG ID
cursor1                     add     a, #4                   'add offset for 2nd mailbox entry
cursor2                     add     mailbox, a              'include offset in mailbox address
mouse_xy                    sets    extm_test, b            'forces external mem off if no mbox
mouseptr                    add     ptrb, lutoffset         'determine hub address of LUT code
wrap                        setq2   #511                    'read up to 512 instructions
skew                        rdlong  $000, ptrb              '...and load into LUT RAM
status                      jmp     #$200                   'continue initialization in LUT RAM

'--------------------------------------------------------------------------------------------------
' Main field/frame generation loop
'--------------------------------------------------------------------------------------------------

fieldloop
                            setq    #8-1                    'read 8 longs from hub
                            rdlong  fieldparams, paramaddr  'reload field parameters to COGRAM
                            setcy   cy                      'setup the colour space converter
                            setci   ci                      'cq is done per scan line (for PAL)
                            mov     regn, regionsize        'setup first region and limit
                            getword regionsize, borders, #0 'extract top border size
                            shr     borders, #16            'extract bottom border size
                            getbyte a, brdrcolour, #0       'extract side border size
                            setword m_brdr, a, #0           'setup number of side border pixels
                            setword m_rf, vis_pixels, #0    'start with default scanline width
                            sub     m_rf, a                 'adjust for left side border
                            sub     m_rf, a                 'adjust for right side border
                            mov     d, #0 wcz               'setup d+c,z flags for mouse+region
                            setbyte brdrcolour, d, #0       'clear out LSB of border colour
                            call    #borderregion           'setup region defaults for border

writestat1                  setbyte status, #$20, #3        'update status - doing back porch
patchvbp                    callpa  #V_BP-0, #blank-0       'send vertical back porch lines

                            mov     ptrb, linebuf1          'restart line buffer
                            test    regionsize  wz          'check if a top border is present
            if_z            call    #newregion              'if not, start a new region
                            mov     pa, vis_lines           'set number of visible lines
                            call    videomode               'begin video after last border line

lineloop
                            call    #hsync                  'do horizontal sync

                            setq2   #15                     'read small palettes at this time
                            rdlong  $100, paletteaddr       'read from hub RAM
            'if_c_and_z      callpb  save, #do_mouse         'c=1, render the mouse after hsync
                            rdfast  #0, save                'setup the streamer read address
                            add     status, #1

                            cmp     pa, borders wz          'check if reached bottom border
            if_z            mov     regionsize, #0          'if yes stop further region updates
            if_z            call    #borderregion           'and go back to border generation
                            test    m_brdr, #255 wz         'check if we have a side border
            if_nz           xcont   m_brdr, brdrcolour      'create left border pixels
                            xcont   m_rf, palselect         'generate the visible line
            if_nz           xcont   m_brdr, brdrcolour      'create right border pixels

                            sub     regionsize, #1 wz       'decrement the region's size count
            if_z            call    #newregion              'when 0, reload another region

                            call    videomode               'create the next video scan line
                            xcont   m_bs, hsync0            'generate horizontal FP blanking
                            djnz    pa, #lineloop           'continue for all active lines

writestat2                  setbyte status, #$40, #3        'update status - doing front porch
patchvfp                    callpa  #V_FP-0, #blank         'send vertical front porch lines

                            add     fieldcount, #1          'increase the field counter
                            test    fieldcount, #15 wz      'check for 16 fields elapsed
flasher     if_z            xor     flash, #$ff             'flash text ~2Hz

syncspace                                                   '!! These 18 instructions must be
                                                            '...maintained for patching into!
                            sub     m_vi, m_slim            'reduces blank line width
proghd0                     add     m_sn, m_slim            'widens sync (SD)
proghd1                     setnib  flipref, #%1111, #7     '...changes back porch (HD)
vsyncon                     drvnot  #0-0                    '(patched) vsync pin on
                            setcmod cmodval
                            mov     hsync0, sync_001        'vsync on, hsync off
                            decod   status, #31             'update status - in vertical sync
                            setbyte status, fieldcount, #2
                            mov     hsync1, sync_000        'vsync on, hsync on

patchvsync                  callpa  #V_SYNC-0, #blank       'send vertical sync blanks
vsyncoff                    xor     cmodval, #1             'vsync pin off
                            setcmod cmodval
                            mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
                            mov     hsync1, sync_002        'vsync off, hsync on
                            add     m_vi, m_slim            'restores blank line width
proghd2                     sub     m_sn, m_slim            'restores sync width (SD)
proghd3                     setnib  flipref, #0, #7         '...or restores back porch (HD)
                            nop                             'must keep room for 18 instructions!

                            jmp     #fieldloop              'continue on to a new field/frame

'--------------------------------------------------------------------------------------------------
' Subroutines
'--------------------------------------------------------------------------------------------------

hsync                       xzero   m_sn, hsync1            'generate the sync pulse
                            wrlong  status, statusaddr      'update the sync status per line
dobreeze                    xcont   m_br, hsync0            'do breezeway before colour burst
                            setcq   cq                      'reapply CQ for PAL colour changes
doburst                     xcont   m_cb, colourburst       'do the PAL/NTSC colour burst
flipref                     xor     cq, palflipcq           'toggle PAL colour output per scanline
bp          _ret_           xcont   m_bv, hsync0            'generate the back porch

'..................................................................................................
blank_pal                   xor     cq, palflipcq           'NEEDS TO BE EVEN DIST. FROM patchvbp!
blank                       call    #hsync                  'do hsync at the start of the line
                            xcont   m_vi, hsync0            'generate blank line pixels
            _ret_           djnz    pa, #blank              'repeat to generate multiple lines

'..................................................................................................
' Code to reload and setup all configurable parameters per display region

newregion                   zerox   regn, #19 wz            'check for any more regions?
borderregion
            if_z            setnib  m_rf, #1, #4            'setup streamer for immediate data
            if_z            setnib  m_rf, #7, #7            'setup streamer for immediate data
            if_z            mov     videomode, #nullmode
                            mov     palselect, brdrcolour   'set default border colour
            if_z            ret     wcz                     'and exit if no more regions

                            setq    #12-1                   'read region parameters from hub
                            rdlong  regn, regn              'update region data
                            getword regionsize, modedata, #1 'extract region size

                            testb   modedata, #9 wc         'determine mode type 1=gfx, 0=text
                            testb   modedata, #12 wz        'check if interlaced source
                            testb   fieldcount, #0 andz     'and with LSB to get field
            if_z_and_c      mov     screenaddr1, cursor1    'select source for interlaced gfx
            if_z_and_c      mov     screenaddr2, cursor2    '...same for wrapped portion
                            bitz    setrowscan, #0          'clear text row scan index
                            mov     palselect, #8           'clear default
                            getbyte rowheight, fontaddr, #3 'extract font height
                            getword rowscan, wrap, #1       'get initial font scanline

            if_z_and_nc     incmod  rowscan, rowheight wz   'wrap rowscan at row height
                            wrz     row                     '..and increase row if required

                            getword wrap, wrap, #0          'clear unwanted top 16 bits now
                            neg     scanline, #1
            if_c            mov     videomode, #gen_gfx     'setup function pointers
            if_nc           mov     videomode, #gen_text    '..for the appropriate mode
                            testb   modedata, #3 wz         'if gfx, 1=LUMA8, 0=non LUMA8
            if_c_and_z      setnib  palselect, modedata, #0
                            getnib  a, modedata, #0         'colour mode 0 is special below
                            cmp     a, #3 wz                'check for the 8 bit LUTRAM mode
            if_c_and_z      mov     palselect, #0           'use low LUTRAM for 8 bit palettes
            if_c_and_z      setq2   #255                    'read in a 256 colour palette from
            if_c_and_z      rdlong  0, paletteaddr          '...HUB to LUT RAM
                            fle     a, #8 wz                'collapse LUMA8 modes, test for 0


p7          if_nc           mov     a, #2                   'override index if text mode
                            alts    a, #modetable           'setup mode table indexing
                            mov     a, 0-0                  'get mode information
            if_c            getbyte transfers, a, #1        'setup transfer count in gfx modes
                            getbyte b, a, #2                'get burst size
                            getnib  bppidx, a, #6           'get bit depth in bpp
                            setnib  m_rf, a, #4             'set streamer nibble 4
                            shr     a, #4                   'prepare next nibble
                            setnib  m_rf, a, #7             'set streamer nibble 7

p0                          mov     linebufsize, #COLS      'compute scan line size in bytes
                            shl     linebufsize, bppidx     '...for the bit depth

                            setd    burst, b
                            testb   modedata, #10 wz        'test for pixel doubling
            if_z            shr     b, #1                   'halve the transfer size if doubled
                            setd    transferloop, b         'value patched is actually size-1
                            add     b, #1                   '...so increment to get real size
                            setd    double, b
                            alts    bppidx, #doublebits
            if_c            mov     pattern, 0-0
                            setd    doubleloop, pattern
            if_c            shr     pattern, #9
            _ret_           mov     ptra, screenaddr1       'restart screen buffer at start

'..................................................................................................
' Code to generate a mouse sprite in all the different colour depths

do_mouse
                            push    ptra
                            push    ptrb

                            testb   modedata, #14 wz
            if_nz           mov     mouse_xy, globalmouse   'use global screen co-ordinates
            if_z            mov     d, scanline             'use local region co-ordinates

                            getword a, mouse_xy, #1         'get mouse y screen co-ordinate
                            getnib  b, mouseptr, #7         'get y hotspot of mouse image
                            sub     a, b                    'compensate for the y hotspot
                            subr    a, d                    'compute sprite row offset
                            cmpr    a, #15 wc               'check if sprite covers scanline

                            alts    bppidx, #bpptable       'bppidx is an index from 0-5
                            mov     bitmask, 0-0            'get table entry using bpp index
                            mul     a, bitmask              'multiply mouse row by its length
                            shr     bitmask, #16 wz         'extract mask portion
            if_z            not     bitmask                 'fix up the 32 bpp case
                            mov     bpp, bitmask
                            ones    bpp                     'convert into real bpp

                            add     a, mouseptr             'add offset to base mouse address
                            setq2   #17-1                   'get 17 longs max, mouse mask+image
                            rdlong  $120, a                 'read mouse data and store in LUT

                            getword offset, mouse_xy, #0    'get mouse x screen co-ordinate
                            getnib  b, mouseptr, #6         'get x hotspot of mouse image

                            mov     pixels, offset
                            sub     offset, b               'compensate for the x hotspot
            if_nc           subr    pixels, vis_pixels wcz  'compute pixels until end of line
                            add     pixels, b               'increase by the x hotspot amount
                            fle     pixels, #16             'limit drawn pixels to 16

            if_c_or_z       jmp     #exitmouse              'exit if sprite is out of x/y range

                            mov     ptrb, #$120             'ptrb is used for mouse image data
                            rdlut   c, ptrb++               'read in the mouse mask first

                            abs     a, offset               'retain offset (and make positive)
                            muls    offset, bpp             'convert number of pixels into bits
                            abs     b, offset wc            'test for negative value (clipped)
                            mov     muxmask, bitmask        'setup mask for pixel's data size
            if_nc           rol     muxmask, b              'align mask for first data pixel
            if_c            rol     bitmask, b              'align mask for first mouse pixel
            if_c            shr     c, a                    'eliminate mouse pixels if clipped
                            shr     b, #5                   'convert bits to longs
            if_c            add     ptrb, b                 'advance mouse data to skip pixels

                            shl     b, #2                   'convert longs to bytes
            if_nc           add     pb, b                   'adjust scanline buffer position
                            setq2   #16-1                   'read 16 scanline longs into LUT
                            rdlong  $110, pb                'using adjusted hub read position

                            mov     ptra, #$110             'ptra used for source image data
                            rdlut   a, ptra                 'get original scanline pixel data
                            test    $, #1 wc                'c=1 will trigger initial read

                            rep     @endmouse, pixels       'repeat loop for up to 16 pixels
            if_c            rdlut   b, ptrb++               'get next mouse sprite pixel(s)
            if_c            rol     b, offset               'align with the source input data
                            shr     c, #1 wc                'get mask bit 1=set, 0=transparent
            if_c            setq    muxmask                 'configure the muxq mask
            if_c            muxq    a, b                    'select original or mouse pixel
            if_c            wrlut   a, ptra                 'write back updated data if altered
                            rol     muxmask, bpp wc         'advance mask by 1,2,4,8,16,32 bits
            if_c            rdlut   a, ++ptra               '...and read next source pixel(s)
                            rol     bitmask, bpp wc         'rotate mask for mouse data reload
endmouse
                            fle     ptra, #$11f             'any way to eliminate this instrn?
                            sub     ptra, #$110
                            setq2   ptra
                            wrlong  $110, pb                'write LUT image data back to hub
exitmouse                   pop     ptrb
                            pop     ptra
                            ret     wcz

'..................................................................................................
' Code to generate the next text scan line and cursor(s)

gen_text
                            mov     b, rowscan              'build font table base address
                            shl     b, #8                   'for this font and row's scanline
                            add     b, fontaddr
                            setq    #64-1                   '64 longs holds 256 bytes of font
                            rdlong  font, b                 'read in font data for scanline

                            testb   modedata, #8 wz         'flashing / full colour background?
p12         if_z            setr    testflash, #$83         'use text flashing code test
p13         if_nz           setr    testflash, #$EA         'change into helpful zerox c,#15 wc

                            testb   modedata, #10 wz        'pixel double test
readrow                     setq2   #COLS/2-1               'read maximum of 120 longs from HUB
                            rdlong  $110, ptra              'to get next 240 chars with colours
p9                          mov     pb, #$10f+COLS/2        'setup LUT read pointer at end
p10         if_z            sub     pb, #COLS/4             '...of where character data is

                            mov     save, ptrb              'save pointer register
                            mov     ptrb, #$1ff             'setup write location in LUT RAM

p1          if_z            sets    adv, #COLS              'increase by half normal columns
p2          if_nz           sets    adv, #COLS*2            'increase by normal columns

patchtext
                            mov     a, #%11000 wc           'reset starting lookup index
p3          if_z            rep     @endwide, #COLS/2       '2100 clocks for 40 double wide
p4          if_nz           rep     @endnormal, #COLS       '2760 clocks for 80 normal wide
                            skipf   a                       'skip 2 of the next 5 instructions
                            xor     a, #%11110              'flip skip sequence for next time
                            rdlut   d, pb                   'read pair of characters/colours
                            getword c, d, #1                'select first word in long (skipf)
                            getword c, d, #0                'select second word in long (skipf)
                            sub     pb, #1                  'decrement LUT read index (skipf)
                            getbyte b, c, #0                'extract font offset for char
                            altgb   b, #font                'determine font lookup address
                            getbyte pixels, 0-0, #0         'get font for character's scanline
testflash                   bitl    c, #15 wcz              'test (and clear) flashing bit
flash       if_c            and     pixels, #$ff            'make it all background if flashing
                            movbyts c, #%01010101           'colours becomes BF_BF_BF_BF
                            mov     b, c                    'grab a copy for muxing step next
                            rol     b, #4                   'b becomes FB_FB_FB_FB
                            setq    ##$F0FF000F             'mux mask adjusts fg and bg colours
                            muxq    c, b                    'c becomes FF_FB_BF_BB
                            testb   modedata, #10 wz        'repeat columns test, z was trashed
endnormal                                                   'end rep 2 instructions early (skipf)
            if_nz           movbyts c, pixels               'select pixel colours for char
            if_nz           wrlut   c, ptrb--               'write coloured pixel data into LUT

                            setword pixels, pixels, #1      'replicate low words in long
                            mergew  pixels                  '...to then double pixels
                            mov     b, c                    'save a copy before we lose colours
                            movbyts c, pixels               'compute 4 lower colours of char
                            ror     pixels, #8              'get upper 8 pixels
                            movbyts b, pixels               'compute 4 higher colours of char
endwide                                                     'end rep 2 instructions early (skipf)
            if_z            wrlut   b, ptrb--               'save it to LUT RAM
            if_z            wrlut   c, ptrb--               'save it to LUT RAM
endpatchtext
                            mov     ptrb, save              'restore ptrb
p5                          setq2   #COLS-1                 'write all column pixels to HUB RAM
p11                         wrlong  $200-COLS, ptrb         'from LUT storage

                            'do both cursors here
p8                          bitz    increment, #2           'setup whether cursor is doubled
                            bitz    scaling, #0               'and multiply offset accordingly

                            rep     @endcursor, #2          'repeat twice for two cursors
                            mov     c, cursor1+0            'get cursor data
                            xor     $-1, #1                 'alternate cursors
                            getbyte a, c, #2                'get cursor's x position (col)
scaling                     shl     a, #2+0                 'transform x to long address offset
                            add     a, ptrb                 'add offset to start of line buffer
                            getnib  b, c, #2
                            sub     b, #1 wc
                            subr    b, rowheight
            if_nc           cmp     b, rowscan wcz          'compare this scanline count
                            testb   c, #13 xorc
                            getbyte b, c, #3                'get cursor's y position (row)
            if_z_or_c       cmp     b, row wz               'check if cursor is on this row
                            testb   c, #15 andz             'check if cursor is enabled

                            testb   c, #12 wc               'select the blink phase to apply
cursflash                   testb   fieldcount, #4-0 xorc   'get flashing bit from field count
            if_c            testb   c, #14 andz             'if blink, apply blink to z

                         '  setnib  c, c, #1                'replicate colour nibble in byte 0
                            movbyts c, #0                   'replicate colour over all 8 pixels
wr1         if_z            wrlong  c, a                    'write cursor color to line buffer
increment                   add     a, #0-0 wc              'advance to next long if wide text
wr2         if_z            wrlong  c, a                    'repeat to get double wide cursor
endcursor
                            testbn  modedata, #11 wz        'z=1 if line doubling off
                            testbn  scanline, #0 orz        'z=1 if second line
            if_z            incmod  rowscan, rowheight wc   'z=1 & c=1 if wrapped

                            testb   modedata, #12 andz
            if_z_and_c      add     rowscan, #1
            if_z_and_nc     incmod  rowscan, rowheight wc

                            wrc     d
adv         if_c            add     ptra, #0-0              'advance by half or full columns
            if_c            add     ptra, skew              'allows windowing into wider screen
                            jmp     #selectbuf              'select next buffer to write to

'..................................................................................................
' Code to generate next graphics scan line and handle external memory access

gen_gfx
                            mov     save, ptrb              'preserve for fifo use later
                            mov     d, ptra                 'preserve initial source pointer
                            getnib  b, screenaddr1, #7
extm_test                   mul     b, #96 wz               'check for external memory usage
                            add     b, mailbox
                            testb   modedata, #13 wc        'check transparent/sprite mode and
            if_c_and_z      mov     save, ptra              '...display from ptra if no ext mem
            if_nz           getnib  a, screenaddr1, #6      'extract bank address
            if_nz           setnib  ptra, a, #6             'copy into external request
            if_nz           setnib  ptra, #EXTMEMREQ, #7    'add memory read request to address
p6          if_nz           mov     a, #COLS                'transfer column "units" of memory data
            if_nz           shl     a, bppidx               '...multiplied by bpp into HUB RAM
            if_nz           setq    #2-1                    'write 2 values
            if_nz           wrlong  save, b                 'setup memory request information
                            sub     b, #4
            if_nz           wrlong  ptra, b                 'initiate memory read request
            if_nz           add     ptra, linebufsize       'increase ptra by this amount
                            bitnz   statusaddr, #20         'remember for late mouse render
            if_c_or_nz      jmp     #copy_done              'no need to do any copy this time

                            testb   modedata, #10 wc        'check for pixel width doubling
            if_nc           setd    writeback, #$188        'no doubling, copied from same addr
            if_c            setd    writeback, #$110        'data copied from different place
                            mov     c, transfers            'setup number of read burst loops
transferloop                setq2   #0-0                    'block copy from HUB source to LUT
                            rdlong  $188, ptra++
double      if_c            callpb  #0-0, #doublepixels     'double pixels when enabled
burst                       setq2   #0-0                    'setup output burst for hub writes
writeback                   wrlong  $0-0, ptrb++            '...and write back to line buffer
                            djnz    c, #transferloop        'repeat
copy_done
                            add     ptra, skew              'allow for some horizontal panning
                            testbn  scanline, #0 wz         'check odd/even line state
                            testb   modedata, #11 wc        'check for line doubled mode
            if_c_and_nz     mov     ptra, d                 'rewind source ptr to repeat line

selectbuf                   testb   ptrb, #31 wz
            if_nz           mov     ptrb, linebuf1
            if_z            mov     ptrb, linebuf2

                            sub     wrap, #1 wz             'check for wrap around to 2nd buf
            if_z            mov     ptra, screenaddr2       'handle it
            if_z            mov     screenaddr1,screenaddr2 'copy into screenaddr1 for later
                            testb   modedata, #9 wc
            if_c_and_z      mov     wrap, rowscan
setrowscan  if_z_and_nc     mov     rowscan, #0
            if_z_and_nc     mov     d, #1
            if_nc           add     row, d

                            add     scanline, #1
                            bitl    statusaddr, #20 wcz     'test&clear when mouse is rendered
                            testb   modedata, #15 wz        'test if mouse shown in this region
                            getword d, status, #0           'get current scanline from top in d
             if_z_and_c     rdlong  a, b                    'check the ext memory request status
             if_z_and_c     tjs     a, #$-1                 'wait until complete line is read

             if_z           callpb  save, #do_mouse
'            if_z_and_nc     callpb  save, #do_mouse         'c=0, render the mouse before hsync
nullmode                                                    'c=1 is returned for a late mouse
            _ret_           setbyte status, #0, #3          'update status - doing active lines

'..................................................................................................
' Code to double pixels in all the different colour depths

doublepixels
                            push    ptra                    'preserve current pointers
                            push    ptrb
                            mov     ptra, #$188             'setup pointers for LUT accesses
                            mov     ptrb, #$110
doubleloop                  rep     #0-0, pb                'patched pixel doubling loop count
                            skipf   pattern                 '1  2  4  8 16 32
                            rdlut   a, ptra++               '*  *  *  *  *  *
                            setq    nibblemask              '      *
                            splitw  a                       '   *
                            mov     b, a                    '*  *  *  *  *
                            movbyts a, #%%2020              '   *
                            movbyts a, #%%1100              '      *  *
                            movbyts a, #%%1010              '*           *
                            wrlut   a, ptrb++               '               *
                            mergeb  a                       '   *
                            mergew  a                       '*
                            mov     pb, a                   '      *
                            shl     pb, #4                  '      *
                            muxq    a, pb                   '      *
                            wrlut   a, ptrb++               '*  *  *  *  *  *Short 32bpp loop
                            movbyts b, #%%3131              '   *           |returns here but
                            movbyts b, #%%3322              '      *  *     |falls through at
                            movbyts b, #%%3232              '*           *  |end after its REP
                            mergew  b                       '*              |block completes.
                            mergeb  b                       '   *           |
                            mov     pb, b                   '      *        |
                            shl     pb, #4                  '      *        |
                            muxq    b, pb                   '      *        |
                            wrlut   b, ptrb++               '*  *  *  *  *  |<skipped for 32bpp
                            jmp     #exitmouse              'share common code to restore ptrs

'--------------------------------------------------------------------------------------------------
' Initialized data
'--------------------------------------------------------------------------------------------------
'                   __instr_skip_patterns____instcount
doublebits  long    %01111001101110110110110_000001001
doublenits  long    %01110111001111011100010_000001010
doublenibs  long    %00001110100001111010100_000001110
doublebytes long    %01111110101111111010110_000000111
doublewords long    %01111101101111110110110_000000111
doublelongs long    %10000000001111101111110_000000100

nibblemask  long    $0ff00ff0

bpptable
            long    $0001_00_08                             '1bpp
            long    $0003_00_08                             '2bpp
            long    $000F_00_0C                             '4bpp
            long    $00FF_00_14                             '8bpp
            long    $FFFF_00_24                             '16bpp
            long    $0000_00_44                             '32bpp

modetable             'bppidx_gfxburst_transfer_nib7_nib4
            long    %00000000_00000000_00000001_0111_0010 + ((COLS/2)-1-(COLS/4)) << 16
            long    %00000001_00000000_00000001_0111_0100 + ((COLS/2)-1) << 16
            long    %00000010_00000000_00000010_0111_0110 + ((COLS/2)-1) << 16
            long    %00000011_00000000_00000100_0111_1000 + ((COLS/2)-1) << 16
            long    %00000011_00000000_00000100_1011_0011 + ((COLS/2)-1) << 16
            long    %00000011_00000000_00000100_1011_0100 + ((COLS/2)-1) << 16
            long    %00000100_00000000_00001000_1011_0101 + ((COLS/2)-1) << 16
            long    %00000101_00000000_00010000_1011_0110 + ((COLS/2)-1) << 16
            long    %00000011_00000000_00000100_1011_0010 + ((COLS/2)-1) << 16


                    '_CHNL0_(R)__CHNL1_(G)__CHNL0_(B)_
sync_000    long    %1101010100_1101010100_1101010100_11    '-vsync -hsync
sync_001    long    %1101010100_1101010100_0010101011_10    '-vsync +hsync
sync_002    long    %1101010100_1101010100_0101010100_11    '+vsync -hsync
sync_003    long    %1101010100_1101010100_1010101011_10    '+vsync +hsync

m_bs        long    $7fb10000 + H_FP                        'front porch before sync
m_sn        long    $7fb10000 + H_SYNC                      'sync
m_br        long    $7fb10000                               'breezeway
m_cb        long    $7fb10000                               'colour burst
m_bv        long    $7fb10000 + H_BP                        'back porch before visible

m_vi        long    $7fb10000 + H_VISIBLE + H_FP            'visible
m_rf        long    $7fb60000 + H_VISIBLE                   'visible 8x4b for LUT lookup

m_brdr      long    $7fb10000
m_half      long    $7fb10000 + 864/2
m_slim      long    $7fb10000 + 432 - 64 - 68



colourburst long    COLOUR_BURST_PAL                        'colour burst colour (patched)
vis_pixels  long    H_VISIBLE
vis_lines   long    V_VISIBLE
fieldcount  long    0

cmodval
lutoffset   long    setupcode - videodriver                 'offset of LUT init code in HUB
videomode
vsyncpin    long    %1111111111_00                          'used to flip hsync
dacmode_s                                                   'hsync 123-ohm 3.3V value below
hsync0      long    %0000_0000_000_1011000000000_01_00000_0
dacmode_c                                                   'R/G/B 75-ohm 2.0V value below
hsync1      long    %0000_0000_000_1011100000000_01_00000_0

fieldparams
palflipcq   long    0
globalmouse long    0
borders     long    0
brdrcolour  long    0
regionsize  long    0
cq          long    CV_PAL_EVEN
font                                                        '64 entry font table stored here
                                                            '...as well as scratch/sync code

            ' SDTV interlaced sync code (larger PAL variant is coded, NTSC is patched over this)

interlacedsd                                                'some different sync code patches
cy                          testb   fieldcount, #0 wc       'field interlace state
ci          if_c            call    #\hsync                 'deal with interlaced field lines
            if_c            xcont   m_slim, hsync0          'send a slim half line
bitmask
ntsc1                       rep #2, #5-0                    'defaults to PAL
muxmask                     xcont   sync_000, hsync1        'generate horizontal blanking/sync
offset                      xcont   sync_001, hsync0

                            decod   status, #31             'update status - in vertical sync
bpp                         setbyte status, fieldcount, #2  'update field counter in status
writestat                   wrlong  status, statusaddr

ntsc2                       rep #2, #5-0                    'defaults to PAL
                            xcont   sync_002, hsync1        'generate horizontal blanking/sync
                            xcont   sync_003, hsync0

ntsc3                       rep #2, #5-0                    'defaults to PAL
                            xcont   sync_000, hsync1        'generate horizontal blanking/sync
                            xcont   sync_001, hsync0
                                                            'PAL variant below is the default
                                                            'while NTSC gets patched
ntsc4       if_c            xor     patchvbp, #1            'generate CQ XOR flip on fields 2,3
ntsc5       if_c            callpa  #1, #$+(blank_pal-syncspace-ntsc5+interlacedsd)  'relocated call
ntsc6       if_nc           xcont   m_half, hsync0          'remainder after half line (PAL)


                ' HDTV interlaced sync code

interlacedhd
                            testb   fieldcount, #0 wc       'get field interlace state
            if_c            call    #\hsync                 'deal with interlaced field lines
            if_c            xcont   m_half, hsync0          'send a half line with sync high

            if_c            mov     a, m_vi
            if_nc           mov     a, m_half

                            decod   status, #31             'update status - in vertical sync
                            setbyte status, fieldcount, #2  'update field counter in status

hdloopstart                 mov     b, #10-0
hdloop                      call    #\hsync
                            xcont   m_half, hsync1
                            xcont   m_bs, hsync0
                            djnz    b, #hdloop

                            call    #\hsync
                            xcont   m_half, hsync0          'generate horizontal blanking/sync
                            xcont   m_bs, hsync0
                            call    #\hsync
                            xcont   a, hsync0
            if_nc           xcont   m_bs, hsync0

            org     font+64                                 'pad out remainder of font/scratch area
'--------------------------------------------------------------------------------------------------
' Uninitialized data
'--------------------------------------------------------------------------------------------------

bppidx      res     1
rowheight                                   'name used in text mode only
pattern     res     1                       'name used in gfx mode only
row                                         'name used in text mode only
transfers   res     1                       'name used in gfx mode only
palselect   res     1
scanline    res     1
rowscan     res     1
pixels      res     1

save        res     1
a           res     1
b           res     1
c           res     1
d           res     1

            fit     $1f6                    'ensure we fit in the COG
'--------------------------------------------------------------------------------------------------
' LUT RAM code (startup configuration only)
'--------------------------------------------------------------------------------------------------
            orgh
setupcode
            org     $200

' temporary configuration code loaded to LUT and executed during driver startup
                            rdlong  ptrb, ptra[-5]          'read pin & custom timing info
 '                           wrlong  c, ptra[-5]             'write our our COG ID
                            mov     pb, ptrb                'make a copy to preserve things
                            bith    linebuf1, #31           'setup buffer toggle bit states
                            bitl    linebuf2, #31           '..in both line buffer addresses
                            mov     save, linebuf1          'initialize for the first time
                            testb   ptrb, #31 wc            'test for analog (0) or digital (1)
            if_c            jmp     #setupdvi               'if digital, do DVI setup
                            testb   ptrb, #30 wc            'test for TV mode (1) or RGB (0)
                            shl     c, #8                   'move cog ID into place for OR
                            or      dacmode_s, c            'install cog ID into sync DAC
                            or      dacmode_c, c            'install cog ID into colour DACs
            if_nc           jmp     #setupvga               'if not TV mode, do VGA setup

setuptv
                            call    #\setuptiming
                            getnib  a, pb, #5               'extract pin group
                            mul     a, #4                   'convert pin group to pin base
                            getbyte b, pb, #3               'get syncoptions field
                            testb   b, #5 wc                'test for HD sync (1), SD sync (0)
            if_c            jmp     #hdtvsync
                            testb   b, #2 wc                'test for composite (0), other (1)
            if_nc           jmp     #compositevideo
                            rczr    b wcz                   'convert two lsb's into flags
            if_c            jmp     #componentvideo

s_video
                            mov     cmodval, #%00_10_1000_0 'enable Y/C video generation
                            add     a, #(1<<6)              'setup two pins (Y+C)
            if_z            add     a, #(1<<6)              'setup three pins (Y+C+Composite)
                            jmp     #sdtvcommon

compositevideo
                            mov     cmodval, #%00_11_1000_0 'enable composite video generation
                            and     b, #3                   'get selected output DAC ID
                            add     a, b                    'add to DAC ID offset
sdtvcommon
                            wrpin   dacmode_c, a            'enable DAC mode on DAC pin(s)
                            dirh    a                       'enable pin output
                            mov     hsync0, #1              'idle hsync
                            mov     hsync1, #2 wz           'active hsync, clear z

                            'sync_000 holds sync/2
                            'sync_001 holds line/2 - sync/2
                            'sync_002 holds line/2 - sync
                            'sync_003 holds sync
interlacedcommon
            if_nz           setr    hsync, #$198            'remove xzero if CVBS or S-Video
                            getword a, m_vi, #0             'get visible + front porch pixels
                            getword b, m_bv, #0             'get back porch pixels
                            add     a, b                    'sum them together
                            getword b, m_sn, #0             'get sync width to be added
                            add     a, b                    'a contains total pixels/line (H)
                            mov     sync_003, b             'store the sync width
                            shr     b, #1                   'b now contains half sync width
                            mov     sync_000, b             'store the half sync width

                            shr     a, #1 wc                'a = H/2
                            setword m_half, a, #0           'setup m_half for half a scan line
                            mov     b, a                    'preserve H/2
                            sub     a, sync_000             'a = H/2 - sync/2
             if_c           add     a, #1
                            mov     sync_001, a             'save this value
                            sub     b, sync_003             'b = H/2 - sync
             if_c           add     b, #1
                            mov     sync_002, b             'save this value
                            mov     m_slim, m_half          'compute m_slim next
                            sub     m_slim, sync_003        'm_slim is half line - sync width
                            getword b, m_bv, #0             'get back porch pixels
                            sub     m_slim, b               'subtract them from m_slim
             if_c           add     m_slim, #1

                            getbyte a, c, #0                'get colour burst pixels
                            setword m_cb, a, #0             'store it in m_cb streamer mode
                            sub     b, a                    'subtract burst from back porch
                            getbyte a, c, #1                'get breezeway pixels
                            setword m_br, a, #0             'store it in m_br streamer mode
                            sub     b, a                    'compensate for breezeway size
            if_nz           setword m_bv, b, #0             'write updated value to back porch
                                                            '..but not for interlaced component

                            mov     a, patchvfp
                            shr     a, #9
                            test    a, #$1ff wz
            if_z            mov     patchvfp, writestat     'no front porch (just equalization)

                            testb   pb, #27 wz              'test for NTSC/PAL (patch for NTSC)
            if_nz           sets    ntsc1, #6               'NTSC uses 6 equalizing pulses
            if_nz           sets    ntsc2, #6               'NTSC uses 6 serrated vsync pulses
            if_nz           sets    ntsc3, #6               'NTSC uses 6 equalizing pulses
            if_nz           mov     ntsc4, #0               'not used for NTSC case
            if_nz           mov     ntsc5, #0               'not used for NTSC case
            if_nz           setnib  ntsc6, #%1100, #7       'turn on if_c condition for NTSC
            if_nz           mov     colourburst, ##COLOUR_BURST_NTSC

                            testb   pb, #28 wc              'test for interlaced/progressive
            if_z_and_nc     sets    ntsc1, #4               'prog PAL uses 4 equalizing pulses
            if_nc           mov     cy, #0
            if_nc           mov     ci, #0
            if_nc           mov     ntsc4, #0
            if_nc           mov     ntsc5, #0
            if_nc           mov     ntsc6, #0

                            getword a, m_sn, #1             'get sync streamer mode top word
                            setword sync_000, a, #1         'and use to build streamer modes
                            setword sync_001, a, #1
                            setword sync_002, a, #1
                            setword sync_003, a, #1

                            callpa  #interlacedsd, #copysync
                            jmp     #setupclk               'now setup the clock

componentvideo
                            mov     cmodval, #%00_01_1_0100 'enable component video generation
            if_nz           xor     cmodval, #%1100         'flip Y/Pr sync outputs if chosen
                            add     a, #(2<<6)+1            'skip DAC0 and setup pins (Y+Pr+Pb)
                            wrpin   dacmode_c, a            'enable DACs in pin group
                            dirh    a                       'enable pin group output
                            testb   pb, #28 wz              'test for interlaced/progressive

                            mov     dobreeze, #0            'kill unwanted instructions
                            mov     doburst, #0
                            mov     sync_003, #0            'idle hsync, idle vsync
                            mov     sync_002, #(-BLANK_LEVEL & $ff)  'active hsync, idle vsync
                            mov     sync_001, #0            'idle hsync, active vsync
                            mov     sync_000, #(-BLANK_LEVEL & $ff)  'active hsync, active vsync
                            mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
                            mov     hsync1, sync_002        'vsync off, hsync on
            if_z            jmp     #interlacedcommon       'interlaced sync version

                            mov     proghd1, #0             'progressive sync version
                            mov     proghd3, #0
                            mov     vsyncon, #0
                            mov     vsyncoff, #0

                            getword m_slim, m_vi, #0        'get normal visible + fp width
                            getword a, m_sn, #0             'get normal sync width
                            sub     m_slim, a               'save the delta for vsync interval
                            jmp     #setupclk

hdtvsync
                            mov     cmodval, #%00_01_1000_0 'enable component video generation
                            add     a, #1                   'skip base DAC0
                            add     a, #(2<<6)              'setup three pins (Y+Pr+Pb)
                            wrpin   dacmode_c, a            'enable DACs on these 3 pins
                            dirh    a                       'enable pin output
                            testb   b, #4 wz                'check for interlaced/progressive
                            and     b, #7                   'use 3 lsb's as sync outputs
                            shl     b, #1
                            or      cmodval, b
                            getword a, m_sn, #0             'get the sync width in pixels
                            shr     a, #1 wc                'split it into two halves
                            setword m_sn, a, #0             'use first half for low sync
                            mov     m_cb, m_sn              'use second half for high sync
            if_c            add     m_cb, #1                'compensate for any odd pixels
                            mov     colourburst, #((+105*60/128)&$ff)
                            mov     hsync1, #((-105*60/128)&$ff)
                            mov     hsync0, #0
            if_z            jmp     #hdtvinterlaced         'do interlaced version

hdtvprogressive
                            mov     proghd0, #0             'kill unwanted instructions
                            mov     proghd2, #0
                            mov     vsyncon, #0
                            mov     vsyncoff, #0
                            mov     flipref, dobreeze       'rearrange streamer instructions
                            mov     dobreeze, #0            'nop away old instruction
                            setnib  flipref, #0, #7         'return early during normal lines
                            sets    bp, #hsync1             'use negative sync "colour"
                            mov     m_br, m_bv              'use breezeway to do back porch
                            getword a, m_bv, #0             'get back porch width
                            getword m_slim, m_vi, #0        'get normal visible + fp width
                            sub     m_slim, a               'save the delta for vsync interval
                            setword m_bv, m_slim, #0        'and keep it in m_bv during vsync

                            mov     sync_003, hsync0        'idle hsync, idle vsync
                            mov     sync_002, hsync1        'active hsync, idle vsync
                            mov     sync_001, hsync0        'idle hsync, active vsync
                            mov     sync_000, hsync1        'active hsync, active vsync
                            jmp     #setupclk

hdtvinterlaced
                            mov     a, patchvsync           'get vertical sync line count
                            shr     a, #9                   '...stored in the d-field
                            shl     a, #1                   'double it (they are half lines)
                            sets    hdloopstart, a          'patch into hd code before copy
                            callpa  #interlacedhd, #copysync

                            getword a, m_vi, #0             'get visible + front porch pixels
                            getword b, m_bv, #0             'get back porch pixels
                            add     a, b                    'sum them together
                            getword b, m_sn, #0             'get sync width to be added
                            add     a, b                    'a contains total pixels/line (H)
                            shr     a, #1                   'a is half line size
                            mov     m_half, m_vi
                            sub     m_half, a
                            getword a, m_bs, #0
                            sub     m_half, a
                            sub     patchvbp, ##$200        'one line gets used by vsync code

                            mov     dobreeze, #0            'nop away old instruction
                            mov     flipref, #0
                            jmp     #setupclk

copysync                    setd    pa, #syncspace          'copy code into space for sync
                            rep     #2, #18                 'repeat 2 instructions 18 times
                            alti    pa, #%111_111           'auto increment
                            mov     0-0, 0-0                'copy longs
                            ret

setupdvi                                                    'code configures for DVI
                            mov     dobreeze, #0
                            mov     doburst, #0
                            mov     m_slim, #0
                            mov     proghd1, #0
                            mov     proghd3, #0
                            call    #\setuptiming           'check for any timing override

            if_z            xor     sync_000, vsyncpin      'setup hsync polarity
            if_z            xor     sync_001, vsyncpin      'flip if +hsync
            if_z            xor     sync_002, vsyncpin      'hsync is otherwise negative
            if_z            xor     sync_003, vsyncpin      'vsync_pin data holds flip mask

            if_c            bitnot  sync_000, #11           'setup vsync polarity
            if_c            bitnot  sync_001, #11           'flipping bit 11 makes +vsync
            if_c            bitnot  sync_002, #11           'vsync is otherwise negative
            if_c            bitnot  sync_003, #11           'by default

                            mov     vsyncoff, #0            'disable sync output instructions
                            mov     vsyncon, #0

                            mov     cmodval, #%10_00_0000_0 'enable DVI in CMOD
                            getnib  a, pb, #5               'extract pin group
                            bitl    a, #3 wcz               'test forward/backward DVI order
                            bitc    cmodval, #7             'setup in CMOD
                            shl     a, #4
                            or      a, #$81
                            setbyte m_bs, a, #2
                            setbyte m_sn, a, #2
                            setbyte m_bv, a, #2
                            setbyte m_vi, a, #2
                            setbyte m_brdr, a, #2
                            add     a, #5
                            setbyte m_rf, a, #2
                            sub     a, #$86
                            shr     a, #1
                            or      a, #7<<6

                            wrpin   ##%10110_1111_0111_10_00000_0, a  '123 ohm BITDAC for pins

                            drvl    a                       'enable DVI output pins in group
                            mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
                            mov     hsync1, sync_002        'vsync off, hsync on
                            mov     a, ##$0CCCCCCC+1        'always set frequency to 1/10 clk
                            jmp     #applyclks

setupvga                                                    'code configures for analog/VGA
                            mov     dobreeze, #0
                            mov     doburst, #0
                            mov     m_slim, #0
                            mov     proghd1, #0
                            mov     proghd3, #0
                            mov     cmodval, #%00_01_0000_0
                            call    #\setuptiming           'check for any timing override

                            bitnz   cmodval, #0             'set hsync polarity default
                            getbyte vsyncpin, pb, #3        'get the vsync pin

                            mov     b, vsyncpin             'get the sync/options field
                            and     b, #%111100             'get base pin of vsync

                            getnib  a, pb, #5               'extract analog 4-pin group
                            mul     a, #4                   'convert to real pin base number

                            mov     sync_003, #0            'idle hsync, idle vsync
                            mov     sync_002, #1            'active hsync, idle vsync
                            mov     sync_001, #0            'idle hsync, active vsync
                            mov     sync_000, #1            'active hsync, active vsync

                            cmp     a, b wz                 'check if pin group matches

                            ' 5pin VGA: RGBHV
            if_nz           drvnc   vsyncpin                'start with inactive vsync
                            setd    vsyncon, vsyncpin
            if_nz           mov     vsyncoff, vsyncon       'use correct method for vsync
            if_nz           jmp     #setup_4pins            'done 5 pin VGA, go setup pins
                            test    vsyncpin, #3 wz         'test 2 lsbs of vsync, 4 cases
                                                            '00: RGBS 1Vp-p sync into 75ohms
                                                            '01: RGB/YPrPb with sync on DAC1
                                                            '10: RGB/YPrPb with sync on DAC2
                                                            '11: RGB/YPrPb with sync on DAC3

                            ' 4pin VGA: RGBS (VGA with Composite Sync)
            if_z            mov     dacmode_s, dacmode_c    'drive 75 ohm sync input, not ttl
            if_z            mov     vsyncon, vsyncoff       'use correct method for vsync
            if_z            jmp     #setup_4pins
                            ' 3pin VGA: RGB/component cases: eg. SyncOnGreen or YPrPb
                            sets    vsyncoff, #0
                            mov     vsyncon, vsyncoff
                            mov     sync_000, #0
                            mov     sync_001, #(256-BLANK_LEVEL)
                            mov     sync_002, #(256-BLANK_LEVEL)
                            mov     sync_003, #0
                            mov     b, #1
                            and     vsyncpin, #3
                            shl     b, vsyncpin
                            or      cmodval, b
                            jmp     #setup_3pins
setup_4pins
                            wrpin   dacmode_s, a            'setup sync mode on DAC0 in group
                            dirh    a                       'enable the sync pin
setup_3pins
                            add     a, #1 + (2<<6)          'setup next pin group
                            wrpin   dacmode_c, a            'setup colour mode on DACs1-3
                            dirh    a                       'enable this pin group
                            mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
                            mov     hsync1, sync_002        'vsync off, hsync on

setupclk
                            rdlong  a, ptrb[4]              'get xfrq value or divider
                            getword b, a, #1                'extract upper long
                            test    b wz                    'check if xrfq value or divider
            if_nz           jmp     #applyclks              'for dividers, upper long is 0
                            getword c, a, #0                'get fractional pixel clock ratio
                            test    c wz                    'check for divide by zero case

            if_z            mov     c, ##2560               '..if so, assume divider is 10.000
                            qfrac   #$80, c                 'divide $80_0000_0000 by ratio
                            getqx   a                       'get quotient
                            getqy   b wz                    'get remainder and test for 0
            if_nz           add     a,  #1                  'round up if a fractional result
applyclks
                            call    #copymono1              'determine type of text mode possible
                            rdlong  b, ptrb[6]              'read CFRQ parameter
                            testb   statusaddr, #21 wz      'check if we want a delayed start
            if_z            waitatn                         '...if so, wait for ATN
                            cogid   c
                            setnib  writestat1, c, #0
                            setcmod cmodval                 'setup using cmod register
                            setcfrq b                       'set the colour modulator rate
                            setxfrq a                       'set the streamer rate
                            jmp     #fieldloop              'begin outputting video frames

setuptiming
                            zerox   ptrb, #19               'check if we have custom timing
                            tjnz    ptrb, #customtiming     'skip if we do
                            mov     a, #H_SYNC_POLARITY     'setup some default polarities
                            sub     a, #1 wz                'z=1 if positive hsync desired
            _ret_           ones    a, #V_SYNC_POLARITY wc  'c=1 if positive vsync desired
                            'read in custom timing block and patch all COG code accordingly
customtiming
                            rdlong  a, ptrb[2]              'read custom horizontal timing
                            getbyte b, a, #0                'get columns
                            fles    b, #240                 'set maximum of 1920 pixels
                            mov     vis_pixels, b           'save as visible columns
                            mul     vis_pixels, #8          'convert to pixels
                            sets    p1, b                   'patch columns into code
                            sets    p4, b
                            sets    p6, b
                            sets    p0, b
                            mov     c, b
                            shl     b, #1                   'compute columns*2
                            sets    p2, b                   'patch columns*2 into code
                            shr     b, #2                   'compute columns/2
                            sets    p3, b                   'patch columns/2 into code
                            sets    p9, b
                            sub     p9, #1
                            setd    readrow, p9             'patch columns/2 - 1 into code
                            add     p9, #$110
                            mov     d, #1
                            subr    d, b
                            setd    row, #modetable+1
                            rep     #2, #8
                            alti    row, #%111_000
settable                    setbyte 0-0, d, #2
                            shr     b, #1                   'compute columns/4
                            sub     d, b
                            setbyte modetable, d, #2
                            sets    p10, b
                            sub     c, #1                   'compute columns -1
                            setd    p5, c                   'patch columns - 1 into code
                            subr    c, #$1ff
                            setd    p11, c
                            setword m_vi, vis_pixels, #0    'setup streamer blank line
                            setword m_rf, vis_pixels, #0    'setup streamer visible line
                            rdword  c, ptrb[10]             'read extended sync timing
                            getnib  b, c, #0                'get bits 8-11 of back porch
                            rolbyte b, a, #1                'get back porch pixels bits 7-0
                            setword m_bv, b, #0             'setup H_BP
                            getnib  b, c, #1                'get bits 8-11 of horizontal sync
                            rolbyte b, a, #2                'get horizontal sync pixels bits 7-0
                            setword m_sn, b, #0             'setup H_SYNC
                            bitl    a, #31 wcz              'get hsync polarity into Z flag
                            getbyte b, a, #3                'get front porch pixels bit6-0
                            shr     c, #1                   'realign extended front porch
                            andn    c, #$7f                 'mask 7 LSBs of unwanted data
                            or      b, c                    'include extended front porch bits
                            setword m_bs, b, #0             'setup H_FP
                            add     m_vi, b                 'include front porch in blank line
                            rdlong  a, ptrb[3]              'read custom vertical timing
                            testb   a, #31 wc               'get vsync polarity into C flag
                            mov     vis_lines, ##$7FF       'setup 11 bit mask
                            and     vis_lines, a            'extract 11 LSb's
                            shr     a, #11
                            setd    patchvbp, a             'setup V_BP
                            shr     a, #9
                            mov     b, #7                   '3 bit mask
                            and     b, a                    'extract 3 LSB's
                            setd    patchvsync, b           'setup V_SYNC
                            shr     a, #3
            if_c            bitnot  a, #8                   'clear this bit for next setd
                            setd    patchvfp, a             'setup V_FP
                            rdword  c, ptrb[11]             'read colour burst params
                            ret                             'returned flags contain polarities!

copymono1
                            testbn   statusaddr, #20 wc     'check if mono text is not forced
                            bitl     statusaddr, #20        'also clear this flag for later use
            if_c            cmp      a, ##$1999999B wc      'then check if at least 5x p2:pixel clock ratio
            if_c            ret                             'if so, return to stick with colour text
                            sets     scaling, #0            'otherwise we can only do mono text
                            sets     p8, #0
                            setr     wr1, #$188             'patch opcode to wrbyte
                            setr     wr2, #$188             'patch opcode to wrbyte
                            cmp      a, ##$2AAAAAAC wc      'check if at least 3x p2:pixel clock ratio
            if_c            jmp      #copymono2             'if so, we can support text attributes
                            setnib   writestat2, #1, #0     'mono without attributes
                            mov      ptra, #p4a-$200
                            rdlut    d, ptra
                            mov      c, p10                 'extract COLS/4
                            sets     d, c                   'patch and writeback to LUT
                            wrlut    d, ptra--
                            mov      b, c
                            and      c, #$1ff
                            shr      c, #1                  'compute COLS/8
                            rdlut    d, ptra
                            sets     d, c                   'patch and writeback to LUT
                            wrlut    d, ptra
                            sub      b, #1
                            setd     p5, b
                            subr     b, #$1ff
                            setd     p11, b
                            mov      flasher, #0            'disable flashing
                            mov      p12, #0
                            mov      p13, #0
                            sets     p7, #0
                            cmp      a, ##$4000_0002 wc     'check if at least 2x pixel clock ratio
            if_c            jmp      #nodisablemono         '...if so, skip disabling mono text
                            mov      c, p10                 'get COLS/4
                            sets     d, c                   'patch instruction
                            setnib   d, #$f, #7             'remove conditional execution
                            setd     d, #1                  'rep loop is now one instruction
                            wrlut    d, ptra                'write back to LUT
                            rdlut    d, ptra[-2]            'read two new instructions to copy
                            wrlut    d, ptra[1]             'and patch LUT
                            rdlut    d, ptra[-1]            'this text mode will only show the background
                            wrlut    d, ptra[2]             'colour with no actual text
nodisablemono
                            setd     c, #patchtext
                            mov      ptra, #startmono1-$200
                            rep      #2, #(endmono1-startmono1)
                            alti     c, #%111_000
                            rdlut    0-0, ptra++
                            ret


' this mono text mode code only support text without attributes
                            wrlut   #0, ptrb--              'these instructions disable
                            jmp     #\endpatchtext          'mono text mode if required
startmono1
p3a         if_z            rep     @endwide2, #COLS/8      'double wide mode
p4a         if_nz           rep     @endnormal2, #COLS/4    'single wide mode

                            rdlut   d, pb                   'read 2 characters
                            sub     pb, #1                  'decrement LUT lookup pos

                            getbyte b, d, #2                'get MS char
                            altgb   b, #font                'lookup font
                            rolbyte c, 0-0, #0              'get pixels

                            getbyte b, d, #0                'get LS char
                            altgb   b, #font                'lookup font
                            rolbyte c, 0-0, #0              'get pixels

            if_z            mov     a, c                    'preserve for double wide
                            rdlut   d, pb                   'read next 2 chars
                            sub     pb, #1                  'decrement LUT lookup pos

                            getbyte b, d, #2                'get MS char
                            altgb   b, #font                'lookup font
                            rolbyte c, 0-0, #0              'get pixels

                            getbyte b, d, #0                'get LS char
                            altgb   b, #font                'lookup font
                            rolbyte c, 0-0, #0              'get pixels

            if_nz           wrlut   c, ptrb--               'store normal wide pixels
endnormal2                  setword c, c, #1                'setup MSW
                            setword a, a, #1                'setup MSW
                            mergew  a                       'double pixels in wide mode
                            mergew  c                       'double pixels in wide mode
            if_z            wrlut   a, ptrb--               'store double wide pixels
            if_z            wrlut   c, ptrb--               'store double wide pixels
endwide2
                            jmp     #\endpatchtext
endmono1

mono2flash                  mov      a, #0
            if_z            mov      a, #$ff

copymono2
                            setnib   writestat2, #2, #0     'mono with attributes
                            mov      ptra, #p4b-$200
                            rdlut    d, ptra
                            sets     d, p3                  'patch COLS/2 and writeback to LUT
                            wrlut    d, ptra--
                            rdlut    d, ptra
                            sets     d, p10                 'patch COLS/4 and writeback to LUT
                            wrlut    d, ptra
                            mov      b, p10                 'extract COLS/4
                            sub      b, #1                  'compute COLS/4 - 1
                            setd     p5, b
                            subr     b, #$1ff
                            setd     p11, b

                            setd     flasher, #p13          'patch flashing register
                            sets     p7, #0
                            mov      ptra, #(mono2flash-$200)
                            rdlut    p12, ptra++
                            rdlut    p13, ptra++

                            setd     c, #patchtext
                            mov      ptra, #startmono2-$200
                            rep      #2, #(endmono2-startmono2)
                            alti     c, #%111_000
                            rdlut    0-0, ptra++
                            ret


' this mono text mode code supports inverse and flashing attributes
startmono2
p3b         if_z            rep     @endwide3, #COLS/4      'double wide mode
p4b         if_nz           rep     @endnormal3, #COLS/2    'single wide mode

                            rdlut   d, pb wc                'read 2 characters, get top attr
                            sub     pb, #1                  'advance source

                            getbyte b, d, #2                'get MS char
                            altgb   b, #font                'lookup font
                            rolbyte c, 0-0, #0              'get pixels
            if_c            andn    c, a                    'if flashing set to background (0)
                            testb   d, #28 wc               'test for inverse attribute
            if_c            xor     c, #$ff                 '...and apply it

                            getbyte b, d, #0                'get LS char
                            altgb   b, #font                'lookup font
                            rolbyte c, 0-0, #0              'get pixels
                            testb   d, #15 wc               'test flashing attribute
            if_c            andn    c, a                    'if flashing set to background (0)
                            testb   d, #12 wc               'test for inverse attribute
            if_c            xor     c, #$ff                 '...and apply it

                            testb   pb, #0 wc
            if_nz_and_c     wrlut   c, ptrb--               'store normal wide pixels every second iteration

endnormal3                  setword c, c, #1                'setup MSW
                            mergew  c                       'double pixels in wide mode
            if_z            wrlut   c, ptrb--               'store double wide pixels
endwide3
                            jmp     #\endpatchtext
endmono2

            fit $400

'--------------------------------------------------------------------------------------------------
            orgh



'  f_xfr        = f_pixel / f_clock * float($7FFF_FFFF)
'  f_csc        = f_color / f_clock * float($7FFF_FFFF) * 2.0
{
chiptiming
        long CLK250MHz
        long 250000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
                long   (SYNC_NEG<<31) | ( 50<<24) | ( 29<<16) | ( 65<<8 ) | (256/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
                long   (SYNC_NEG<<31) | ( 27<<23) | (  0<<20) | ( 35<<11) | 192
                long   round(f_xfr)
                long   (7<<24) + (18<<16)
                long   round(f_csc) ' 284704235/2 'reserved for CFRQ parameter
}

prog240_timing     '720x240p timing @ 60Hz with 13.5MHz pixel clock
            long   CLK108MHz
            long   108000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 16<<24) | ( 64<<16) | ( 58<<8 ) | (720/8)
            'long  (SYNC_NEG<<31) | ( 56<<24) | ( 64<<16) | ( 98<<8 ) | (640/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 0<<23) | (  0<<20) | ( 13<<11) | 240
            long   8<<8
            long   (8<<24) + (36<<16)
            'long    round(3579545.0 / 108000000.0 * float($7FFFFFFF) * 2.0)
            long   284704235/2 'reserved for CFRQ parameter

{
prog240_timing     '720x240p timing @ 60Hz with 14.31818MHz pixel clock
        long CLK114_5MHz
        long 114545454
                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 26<<24) | ( 68<<16) | ( 96<<8 ) | (720/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 13<<11) | 240
            long 1<<28
            long   (16<<24) + (36<<16)
        long 1<<27
}

prog288_timing     '720x288p timing @ 50Hz with 13.5MHz pixel clock
            long   CLK108MHz
            long   108000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 12<<24) | ( 64<<16) | ( 68<<8 ) | (720/8)
            'long   (SYNC_NEG<<31) | ( 52<<24) | ( 64<<16) | (108<<8 ) | (640/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 17<<11) | 288
            long   8<<8
            long   (16<<24) + (30<<16)
            long   352634214/2' reserved for CFRQ parameter

int480_timing      '720x480i timing @ 60Hz with 14.31818MHz pixel clock

        long CLK114_5MHz
        long 114545454
                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 26<<24) | ( 68<<16) | ( 96<<8 ) | (720/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 13<<11) | 240
            long 1<<28
            long   (16<<24) + (36<<16)
        long 1<<27

{
int480_timing      '720x480i timing @ 60Hz with 13.5MHz pixel clock

        long CLK229MHz
long 229000000
                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 26<<24) | ( 68<<16) | ( 96<<8 ) | (720/8)
                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 13<<11) | 240
            long 67135496*2 '32<<8
                 long   (14<<24) + (36<<16)
        long 67135496 ' 1<<26
}
int576_timing
            long   CLK141_875MHz
            long   141875000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 32<<24) | ( 66<<16) | ( 90<<8 ) | (720/8)
            'long   (SYNC_NEG<<31) | ( 52<<24) | ( 64<<16) | (108<<8 ) | (640/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 17<<11) | 287
            long   10<<8
            long   (13<<24) + (32<<16)
            long   134217728

{
int576_timing      '720x576i timing @ 50Hz with 13.5MHz pixel clock
            long   CLK108MHz
            long   108000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 12<<24) | ( 64<<16) | ( 68<<8 ) | (720/8)
            'long   (SYNC_NEG<<31) | ( 52<<24) | ( 64<<16) | (108<<8 ) | (640/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 17<<11) | 287
            long   8<<8
            long   (16<<24) + (30<<16)
            long   176317107
}

prog480_timing     '720x480p timing @ 60Hz with 27MHz pixel clock
            long   CLK135MHz
            long   135000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 16<<24) | ( 48<<16) | ( 74<<8 ) | (720/8)
            'long   (SYNC_NEG<<31) | ( 16<<24) | ( 64<<16) | ( 58<<8 ) | (720/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 7<<23) | (  6<<20) | ( 32<<11) | 480
            long   5<<8
            long   (8<<24) + (36<<16)
            long   0   ' reserved for CFRQ parameter

prog576_timing     '720x576p timing @ 50Hz with 27MHz pixel clock
            long   CLK135MHz
            long   135000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 12<<24) | ( 48<<16) | ( 84<<8 ) | (720/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 5<<23) | (  5<<20) | ( 39<<11) | 576
            long   5<<8
            long   (8<<24) + (30<<16)
            long   176317107   ' reserved for CFRQ parameter

vga_timing         'VGA resolution 640x480 60Hz with 25.2MHz pixel clock
            long   CLK252MHz
            long   252000000

                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 10<<23) | (  2<<20) | ( 33<<11) | 480
            long   10 << 8 ' $0ccccccc+1
            long   0
            long   0   ' reserved for CFRQ parameter

dvi_timing         'VGA resolution 640x480 60Hz with 25.2MHz pixel clock
            long   CLK252MHz
            long   252000000

                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 10<<23) | (  2<<20) | ( 33<<11) | 480
            long   10 << 8
            long   0
            long   0   ' reserved for CFRQ parameter

vga400_timing      'VGA resolution 640x400 70Hz with 25.2MHz pixel clock
            long   CLK252MHz
            long   252000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_POS<<31) | ( 12<<23) | (  2<<20) | ( 35<<11) | 400
            long   10 << 8
            long   0
            long   0   ' reserved for CFRQ parameter

wvga_dvi_timing   ' reduced blanking for 800x480 60Hz LCD at 27MHz pixel clk YMMV
            long   CLK270MHz
            long   270000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_POS<<31) | ( 16<<24) | ( 16<<16) | ( 50<<8 ) | (800/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_POS<<31) | (  7<<23) | (  3<<20) | ( 20<<11) | 480
            long    10 << 8
            long    0
            long    0   ' reserved for CFRQ parameter

ega_timing         'EGA resolution 640x350 70Hz with 25.2MHz pixel clock
            long   CLK252MHz
            long   252000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_POS<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | ( 37<<23) | (  2<<20) | ( 60<<11) | 350
            long   10 << 8
            long   0
            long   0   ' reserved for CFRQ parameter

svga_timing   ' SVGA resolution 800x600 60Hz with 40MHz pixel clock
            long   CLK240MHz
            long   240_000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_POS<<31) | ( 40<<24) | (128<<16) | ( 88<<8 ) | (800/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_POS<<31) | (  1<<23) | (  4<<20) | ( 23<<11) | 600
            long    6 << 8
            long    0
            long    0   ' reserved for CFRQ parameter

svga_dvi_timing   ' massively reduced blanking for 800x600 50Hz at 25.2MHz clk YMMV
            long   CLK252MHz
            long   252000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_POS<<31) | (  8<<24) | (  8<<16) | (  8<<8 ) | (800/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_POS<<31) | (  2<<23) | (  2<<20) | ( 11<<11) | 600
            long    10 << 8
            long    0
            long    0   ' reserved for CFRQ parameter

xga_timing ' 1024x768@60Hz at 65*5 MHz YMMV
            long   CLK325MHz
            long   325000000
       '    long   CLK200MHz
       '    long   200000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 24<<24) | (136<<16) | (160<<8 ) |(1024/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | (  3<<23) | (  6<<20) | (29<<11) | 768
            long    5 << 8
            long    0
            long    0   ' reserved for CFRQ parameter

sxga_timing ' 1280x1024@60Hz at 108*2 MHz YMMV
            long   CLK216MHz
            long   216000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_POS<<31) | ( 48<<24) | (112<<16) | (248<<8 ) |(1280/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | (  1<<23) | (  3<<20) | ( 38<<11) | 1024
            long   2 << 8
            long   0
            long   0   ' reserved for CFRQ parameter

uxga_timing ' 1600x1200@60Hz at 162*2 MHz
            long   CLK325MHz
            long   324000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_POS<<31) | (64<<24) | (192<<16) | (48<<8 ) |(1600/8)
                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits

            long   (SYNC_POS<<31) | (  1<<23) | (  3<<20) | ( 46<<11) | 1200
            long   2 << 8
                   '_Breezeway__C-Burst__FrontPorchHi__SyncWidthHi__BackPorchHi
                   '  8 bits     8 bits     8 bits        4 bits        4 bits
            long   (1 << 0)  ' Back porch MSBs
            long   0   ' reserved for CFRQ parameter


wuxga_timing ' experimental 1920x1200@60Hz for Dell 2405FPW at 77*4 MHz YMMV
            long   CLK308MHz
            long   308000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_POS<<31) | ( 16<<24) | ( 16<<16) | (128<<8 ) |(1920/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | (  8<<23) | (  3<<20) | ( 23<<11) | 1200
            long   2<<8
            long   0
            long   0   ' reserved for CFRQ parameter

hd60_timing
            'long   CLK350MHz
            'long   350000000
            long   CLK297MHz
            long   297000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 70<<24) | ( 80<<16) | (220<<8 ) |(1280/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | (  5<<23) | (  5<<20) | ( 20<<11) | 720
            long   4<<8
            long   0
            long   0   ' reserved for CFRQ parameter

hd50_timing
            long   CLK297MHz
            long   297000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_NEG<<31) | ( 16<<24) | ( 80<<16) | (220<<8 ) |(1280/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_NEG<<31) | (  5<<23) | (  5<<20) | ( 20<<11) | 720
            long   4<<8
                   '_Breezeway__C-Burst__FrontPorchHi__SyncWidthHi__BackPorchHi
                   '  8 bits     8 bits     8 bits        4 bits        4 bits
             long   (3 << 8)                         'extended front porch
            long   0   ' reserved for CFRQ parameter

fullhd_timing
            long   CLK297MHz
            long   297000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_POS<<31) | ( 88<<24) | ( 44<<16) | (148 <<8 ) |(1920/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_POS<<31) | (  4<<23) | (  5<<20) | ( 36<<11) | 1080
            long   2<<8
            long   0
            long   0   ' reserved for CFRQ parameter

fullhd50_timing
            long   CLK297MHz
            long   297000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_POS<<31) | ( 16<<24) | ( 44<<16) | (148 <<8 ) |(1920/8)
           ' long   (SYNC_POS<<31) | (  0<<24) | ( 44<<16) | (252 <<8 ) |(1920/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     8 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_POS<<31) | (  4<<23) | (  5<<20) | ( 36<<11) | 1080
            long   2<<8
                   '_Breezeway__C-Burst__FrontPorchHi__SyncWidthHi__BackPorchHi
                   '  8 bits     8 bits     8 bits        4 bits        4 bits
            long   (4<<8) ' 528 ' 424 '528
            long   0   ' reserved for CFRQ parameter

hdint_timing
            long   CLK350MHz
            long   350000000
                   '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
                   '     1 bit         7 bits      8 bits      8 bits    8 bits
            long   (SYNC_POS<<31) | ( 44<<24) | ( 88<<16) | (148<<8 ) |(1920/8)

                   '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
                   '     1 bit         8 bits      3 bits      9 bits   11 bits
            long   (SYNC_POS<<31) | (  2<<23) | (  5<<20) | ( 15<<11) | 540
            long   5<<8
            long   0
            long   0
