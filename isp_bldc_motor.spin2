'' =================================================================================================
''
''   File....... isp_bldc_motor.spin2
''   Purpose.... Object providing control interface for a single BLDC motor
''   Authors.... Stephen M Moraco
''               -- Copyright (c) 2022 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Feb 2022
''   Updated.... 9 Feb 2022
''
'' =================================================================================================

CON { Public Interface Constants }

  '  ID where the P2 Eval Motor Board is plugged in (Enum)
  #0[16], PINS_P0_P15, PINS_P16_P31, PINS_P32_P47

  ' Driver Distance-Units Enum
  #0, DDU_Unknown, DDU_IN, DDU_MM

  ' Driver Rotation-Units Enum
  #0, DRU_Unknown, DRU_DEGREES, DRU_ROTATIONS

  ' Driver Time-Unit Enum
  #0, DTU_Unknown, DTU_MILLISEC, DTU_SEC

  ' Driver Status Enum
  #0, DS_Unknown, DS_MOVING, DS_HOLDING, DS_OFF

CON { test pins for LA measurement }

  ' PIN_8 - PIN_15
  TEST_BASE_PIN = 8
  TEST_ALL_PINS = TEST_BASE_PIN addpins 7
  TEST_PIN_OUTER_LOOP = 8
  TEST_PIN_SENSE_LOOP = 9

CON { driver internal Constants}

  FRAME    = 1024 * 6 / 2       '6 ADC samples make 1 PWM frame, divide by two for triangle PWM
  OFFSET   = 40                ' enforced dead time in clock cycles (at 200_000_000)
  PWMLIM   = FRAME - OFFSET     'PWM duty hard limit

VAR { Data Structure for PASM Driver }
  ' remember these are zeroed at run time
    long    motorCog                            ' record ID of cog we start (0 = not started)
    long    senseCog                            ' record ID of cog we start (0 = not started)

    long    maxDrvTics                      ' accumulators for study of driver
    long    minDrvTics

    long    pinbase                             ' 1 long                must set initially
    long    params_ptr                          ' 1 long                must set initially
    long    angle                               ' 1 long                must set continually
    ' 12 longs come from driver, 13th fault also from driver but only when happens
    long    drive_u, drive_v, drive_w           ' 3 sequential longs    returns data continually
    long    sense_u, sense_v, sense_w, sense_i  ' 4 sequential longs    returns data continually
    long    hall, pos, duty, err                ' 4 sequential longs    returns data continually
    long    loop_ticks                          ' 1 sequential long     returns loop duration in ticks continually
    long    fault                               ' 1 sequential long     written to 1 on fault

VAR { Data for Motor Position Tracking }

    long    winIndex
    long    winEntryCt
    long    newCntsInSec
    long    windowSum
    ' ------ HDMI monitored! -----
    long    rpmIn10ths
    long    rpm
    long    cntsInSec
    long    deltaTicks
    ' -----------------------------
    long    priorPos
    long    rpmTenths

CON { Constants for HDMI Debug }

    DBG_GROUPS_CT = 2
    DBG_MAX_VARS_IN_GROUP = 5

VAR { Data Structure for HDMI Debug }

    long    pTitlesAr[DBG_GROUPS_CT]
    long    pVarCtAr[DBG_GROUPS_CT]
    long    pNamesAr[DBG_GROUPS_CT*DBG_MAX_VARS_IN_GROUP]
    long    pValsAr[DBG_GROUPS_CT*DBG_MAX_VARS_IN_GROUP]

DAT { Literals for HDMI Debug }
' motor drive data
    nameTitle1   byte    "Motor Drv",0
    name10      byte    "hall",0
    name11      byte    "pos",0
    name12      byte    "duty",0
    name13      byte    "err",0
    nextAddr1
    dataLen1     long    @nextAddr1 - @nameTitle1

' motor sense data
    nameTitle2   byte    "Motor Sns",0
    name20      byte    "RPM 10ths",0
    name21      byte    "RPM",0
    name22      byte    "cnts/sec",0
    name23      byte    "delta",0
    nextAddr2
    dataLen2     long    @nextAddr2 - @nameTitle2

PRI loadDisplayList() | nGrpOffset, nValsGrpOffset, nVarsInGroup
' do internal one-time setup of driver debug data
    nGrpOffset := 0
    nVarsInGroup := 4
    LONG[@pTitlesAr][nGrpOffset] := @nameTitle1
    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup
    ' populate the empty name/value ptr tables
    nValsGrpOffset := nGrpOffset * nVarsInGroup
    LONG[@pNamesAr][nValsGrpOffset + 0] := @name10
    LONG[@pNamesAr][nValsGrpOffset + 1] := @name11
    LONG[@pNamesAr][nValsGrpOffset + 2] := @name12
    LONG[@pNamesAr][nValsGrpOffset + 3] := @name13
    LONG[@pValsAr][nValsGrpOffset + 0] := @hall
    LONG[@pValsAr][nValsGrpOffset + 1] := @pos
    LONG[@pValsAr][nValsGrpOffset + 2] := @duty
    LONG[@pValsAr][nValsGrpOffset + 3] := @err

    nGrpOffset := 1
    nVarsInGroup := 4
    LONG[@pTitlesAr][nGrpOffset] := @nameTitle2
    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup
     ' populate the empty name/value ptr tables
    nValsGrpOffset := nGrpOffset * nVarsInGroup
    LONG[@pNamesAr][nValsGrpOffset + 0] := @name20
    LONG[@pNamesAr][nValsGrpOffset + 1] := @name21
    LONG[@pNamesAr][nValsGrpOffset + 2] := @name22
    LONG[@pNamesAr][nValsGrpOffset + 3] := @name23
    LONG[@pValsAr][nValsGrpOffset + 0] := @rpmIn10ths
    LONG[@pValsAr][nValsGrpOffset + 1] := @rpm
    LONG[@pValsAr][nValsGrpOffset + 2] := @cntsInSec
    LONG[@pValsAr][nValsGrpOffset + 3] := @deltaTicks

PUB getDebugData() : nGroups, pGroupTitles, pGroupNames, pGroupVarCts, pGroupVars | tmpAbsPtr
'' Return pointers to debug data structures for this motor-object instance
    loadDisplayList()
    nGroups := DBG_GROUPS_CT
    pGroupTitles := @pTitlesAr         ' pStr = long[pTitlesAr][grpIdx]
    pGroupVarCts := @pVarCtAr          ' nNbrGrpVars = long[pVarCtAr][grpIdx]
    pGroupNames := @pNamesAr           ' pGrpNameAr = long[pNamesAr][grpIdx], pVarName = long[pNameAr][varIdx]  where varIdx is from 0 to nNbrGrpVars - 1
    pGroupVars := @pValsAr             ' pGrpLongVar = long[pValsAr][grpIdx][varIdx]  where varIdx is from 0 to nNbrGrpVars - 1
    debug("* -------------")
    debug("* MOTR DAT values: ", uhex_long(@hall), uhex_long_array(@hall, 4))
    debug("* MOTR VAR values: ", uhex_long(@rpmIn10ths), uhex_long_array(@rpmIn10ths, 4))
    debug("* NAMEs SOURCE1: ", uhex_long(@nameTitle1), uhex_byte_array(@nameTitle1, dataLen1))
    debug("* NAMEs SOURCE2: ", uhex_long(@nameTitle2), uhex_byte_array(@nameTitle2, dataLen2))
    debug("* -------------")
    debug("* MOTR Disply List: ", uhex_long(@pTitlesAr), uhex_long_array(@pTitlesAr, (2 * DBG_GROUPS_CT) + (2 * DBG_GROUPS_CT * DBG_MAX_VARS_IN_GROUP)))
    debug("* -------------")
    debug("* MOTR PARM values: ", uhex_long(@nGroups), uhex_long_array(@nGroups, 5))
    debug("* -------------")
    debug("* MOTR Sent: ", udec(nGroups), uhex_long(pGroupTitles), uhex_long(pGroupNames), uhex_long(pGroupVarCts), uhex_long(pGroupVars))
    debug("* =============")

DAT
    msTicks     long    0
    ticks125ms  long    0                     ' time constants based on CPU freq
    ticks500us  long    0                     '
    ticks750us  long    0                     '
    ticks800us  long    0                     '
    ticks1ms    long    0                     '

PUB null()

'' This is not a top-level object

CON { --- Subsystem Configuration --- }

  INVALID_PIN_BASE = -1

PUB start(motorBasePin) : ok | legalBase
'' Specify motor control board connect location for this motor and start the driver
' setup runtime constants
        ticks125ms := (CLKFREQ / 1_000) * 125
        ticks500us := (CLKFREQ / 1_000_000) * 500
        ticks750us := (CLKFREQ / 1_000_000) * 750
        ticks800us := (CLKFREQ / 1_000_000) * 800
        msTicks := ticks1ms := (CLKFREQ / 1_000)

        loop_ticks := 0
        minDrvTics := 65535

    ' ensure we only use legal values
    legalBase := motorBasePin
    CASE motorBasePin
        PINS_P0_P15 :
        PINS_P16_P31 :
        PINS_P32_P47 :
        OTHER :
            legalBase := INVALID_PIN_BASE

    ' if legal base-pin then start cog
    if legalBase <> INVALID_PIN_BASE
        pinbase := motorBasePin     ' record base pin number
        params_ptr := @params       ' point to driver variables
        ok := motorCog := coginit(NEWCOG, @driver, @pinbase) + 1

PUB startSenseCog() : ok
    ok := senseCog := cogspin(NEWCOG, taskPostionSense(), @taskStack) + 1
    if senseCog == 0    ' did fail?
        debug("!! ERROR filed to start Position Sense task")

PUB stop()
'' Stop cog and release pins assigned to this motor

    if motorCog
        cogstop(motorCog - 1)
        motorCog := 0

    ' Bottom 8 pins are sensed, top 8 are driven, so clear only the top 8
    pinclear(pinbase+8 addpins 7)



PUB setAcceleration(rate)
'' Limit Acceleration to {rate} where {rate} is [??? - ???] mm/s squared (default is ??? mm/s squared)

PUB setMaxSpeed(speed)
'' Limit top-speed to {speed} where {speed} is [??? - ???] mm/s (default is ??? mm/s)

PUB setMaxSpeedForDistance(speed)
'' Limit top-speed of driveDistance() operations to {speed} where {speed} is [??? - ???] mm/s (default is ??? mm/s)

PUB calibrate()
'' (we may need this?)

PUB holdAtStop(bEnable)
'' Informs the motor control cog to actively hold postiion (bEnable=true) or coast (bEnable=false) at end of motion

PUB resetTracking()
'' Resets the position tracking values returned by getDistance() and getRotations()

CON { --- Subsystem Control --- }

PUB driveForDistance(distance, distanceUnits)
'' Control the forward direction of this motor using the {distance} and {distanceUnits} inputs.
'' Turn the motor on then turn it off again after it reaches the specified {distance} in {distanceUnits} [DDU_IN or DDU_MM].
'' AFFECTED BY:  setAcceleration(), setMaxSpeedForDistance(), holdAtStop()

PUB driveAtPower(power) | limitPwr
'' Control the speed and direction of this motor using the {power, [(-100) to 100]} input.
'' Turns the motor on at {power}.
'' AFFECTED BY:  setAcceleration(), setMaxSpeed(), holdAtStop()
    limitPwr :=  -100 #> power <# 100

PUB stopAfterRotation(rotationCount, rotationUnits)
'' Stops the motor after it reaches {rotationCount} of {rotationUnits} [DRU_DEGREES, DRU_ROTATIONS].
'' USE WITH:  driveDirection(), drive()

PUB stopAfterDistance(distance, distanceUnits)
'' Stops the motor after either it reaches {distance} specified in {distanceUnits} [DDU_IN or DDU_MM].
'' USE WITH:  driveDirection(), drive()

PUB stopAfterTime(time, timeUnits)
'' Stops the motor, after {time} specified in {timeUnits} [DTU_IN_MILLISEC or DTU_IN_SEC] has elapsed.
'' USE WITH:  driveDirection(), drive()

PUB stopMotor()
'' Stops the motor, killing any motion that was still in progress
''  AFFECTED BY:holdAtStop()

CON { --- Subsystem Status --- }

PUB getDistance(distanceUnits) : distanceInUnits
'' Returns the distance in {distanceUnits} [DDU_IN or DDU_MM] travelled by this motor since last reset

PUB getRotationCount(rotationUnits) : rotationCount
'' Returns accumulated {rotationCount} in {rotationUnits} [DRU_DEGREES, DRU_ROTATIONS], since last reset, for this motor.

PUB getStatus() : eStatus
'' Returns status of motor drive state for this motor: enumerated constant: DS_MOVING, DS_HOLDING or DS_OFF
    eStatus := DS_OFF   ' force this for now...


CON { --- PRIVATE Utility Methods --- }
DAT { debug vars }

    maxRpm  long    0               ' tracking max for debug out reasons
    useDebug   long    TRUE

CON { --- The Motor driver --- }

  STABILIZE_LOOP_CT = 2000

PUB testMotor() | priorHall, angleIncrement, faultHoldoffCtr, startTicks, runLoopCount, increment, decrement, angleTarget, bStartingUp, loopCtr
'' invoke start() before invoke of testMotor()
    if useDebug
        debug(`logic l title 'Hall Effect' pos 25 440 'Hall' 3)

        debug(`term t title 'Status' pos 650 650 size 30 1 textsize 20 update)

        debug(`term v title 'Distance/Speed' pos 650 30 size 70 5 textsize 12 update)

        debug(`term c title 'Calcs' pos 650 294 size 70 5 textsize 12 update)

        debug(`term i title 'Instrument' pos 650 165 size 70 5 textsize 12 update)

        debug(`scope r title 'Duty and Error' pos 363 439 size 256 256 samples 256 rate 50)
        debug(`r 'Duty' 0 `(PWMLIM<<4) 256 0)
        debug(`r 'Error' -128 128 256 0 15)

        debug(`scope s title 'Voltages' pos 105 60 size 512 300 samples 256 rate 256)
        debug(`s 'U' 0 `(FRAME) 128 170)
        debug(`s 'V' 0 `(FRAME) 128 170)
        debug(`s 'W' 0 `(FRAME) 128 170)
        debug(`s 'Iu' 0 2000 128 70)
        debug(`s 'Iv' 0 2000 128 70)
        debug(`s 'Iw' 0 2000 128 70)
        debug(`s 'P' 0 100 128 10)
    pintoggle(TEST_ALL_PINS)
    pintoggle(TEST_ALL_PINS)
    pintoggle(TEST_ALL_PINS)
    pinlow(TEST_ALL_PINS)

    bStartingUp := true
    angleTarget := 110_000_000
    increment := 50_000
    decrement := 50_000
    angleIncrement := 0

    runLoopCount := 20_000 ' count of 1 ms loops (20 seconds)
    'runLoopCount := 30_000 ' count of 1 ms loops (30 seconds)
    'runLoopCount := 40_000 ' count of 1 ms loops (40 seconds)


    'repeat

    repeat
        loopCtr++
        pintoggle(TEST_PIN_OUTER_LOOP)
        pintoggle(TEST_PIN_OUTER_LOOP)

        startTicks := getct()

        if runLoopCount > 0 && bStartingUp == false
            runLoopCount--
            if runLoopCount +// 1000 == 0
                if useDebug
                    debug(`i 0 'calc lpCt=`udec_(runLoopCount)' update)

        if hall <> priorHall                    'if hall effect changed, update logic display
            if useDebug
                debug(`l `ubin_byte_(hall))
            priorHall := hall

        if useDebug
            debug(`t 0 '`sdec(duty, pos)' update)       'update terminal and scope displays
            debug(`r `sdec_(duty, err))
            debug(`s `sdec_long_array_(@drive_u,3) `sdec_long_array_(@sense_u,4))
        maxDrvTics := loop_ticks > maxDrvTics ? loop_ticks : maxDrvTics
        minDrvTics := loop_ticks > 10 && loop_ticks < minDrvTics  ? loop_ticks : minDrvTics
        if rpm > maxRpm
            maxRpm := rpm
            if useDebug
                debug(`v 0 'cnts=`udec_(cntsInSec) rpm=`udec_(rpm).`udec_(rpmTenths) drvCt=`udec_(loop_ticks) [`sdec_(minDrvTics) - `udec_(maxDrvTics)]' update)       'update speed/distance display

        '  ---------------------------------------------------------------
        '  increment the angle for 30 seconds, then slow-down, stop motor
        '  ---------------------------------------------------------------
        ' ramp down to ZERO at end
        if runLoopCount == 0
            if angleIncrement > decrement
                angleIncrement -= decrement
            elseif angleIncrement <= decrement
                angleIncrement := 0
            'debug(`i 0 'calc lpCt=`udec_(runLoopCount), incr=`udec_(angleIncrement), decr=`udec_(decrement)' update)

        ' ramp up to TARGET
        if bStartingUp
            ' every N iterations increment ramp
            if loopCtr +// 4 == 0
                if angleIncrement <> angleTarget
                    angleIncrement += increment
                    if angleIncrement > angleTarget
                        angleIncrement := angleTarget
                else
                    bStartingUp := false    ' done starting...
            'debug(`i 0 'calc lpct=`udec_(runLoopCount), incr=`udec_(angleIncrement), decr=`udec_(angleTarget)' update)

        angle += 10_000_000                                'update angle to turn motor
        'angle += angleIncrement                                'update angle to turn motor
        'angle += qsin(1<<28, angleIncrement += 90_000, 0)        'update angle to turn motor

        if faultHoldoffCtr++ < STABILIZE_LOOP_CT            ' if still getting sense of motor hold-off faults
            fault~
        if fault and faultHoldoffCtr > STABILIZE_LOOP_CT and 0   ' if fault, shut down
            if useDebug
                debug(`t 0 'FAULT' update)
            stop()
            repeat    ' and lock here!

        'waitus(1000)
        waitct(startTicks + ticks1ms)    ' wait to create time base (1000 ok, 500 faults motor w/angle!!)

CON { TASK position tracking }

  STACK_SIZE_LONGS = 48
  WINDOW_SIZE = 5

VAR { arrays }
    long    countsWindow[WINDOW_SIZE]
    long    taskStack[STACK_SIZE_LONGS]

PRI taskPostionSense() | senseStartTicks
' TASK: every 1/8 Sec (8Hz) read motor pos and calculate RPM and countOf90ths/Sec

    longfill(@countsWindow, 0, WINDOW_SIZE) ' zero our window accum

    repeat
        senseStartTicks := getct()
        pintoggle(TEST_PIN_SENSE_LOOP)
        pintoggle(TEST_PIN_SENSE_LOOP)

        newCntsInSec := distanceIn90ths(pos)            ' Read the next sensor value
        windowSum -= LONG[@countsWindow][winIndex]          ' Remove the oldest entry from the sum
        long [@countsWindow][winIndex] := newCntsInSec      ' place the newest reading into the window
        windowSum += newCntsInSec                           ' Add the newest reading to the sum
        winIndex := (winIndex + 1) +// WINDOW_SIZE          ' Increment the index, and wrap to 0 if it exceeds the window size
        if winEntryCt < WINDOW_SIZE                         ' incr number of samples in sum until is window size
            winEntryCt ++

        cntsInSec := (windowSum / winEntryCt) * 8                 ' moving average, scaled
        'debug(`i 0 'calc new=`udec_(newCntsInSec), sum=`udec_(windowSum), idx=`udec_(winIndex), ct=`udec_(winEntryCt), avg=`udec_(cntsInSec)' update)
        rpmIn10ths := (cntsInSec * 60) / 9
        rpm := rpmIn10ths / 10
        rpmTenths := rpmIn10ths +// 10

        deltaTicks := getct() - senseStartTicks
        'debug(`i 0 'tic Delta=`udec_(deltaTicks), ms=`udec_(msTicks)' update)

        ' code uses about 1_880 ticks. This is little over 9 uS  @200MHz clock
        '   wait remainder of 125 mSec before next sample
        waitct(senseStartTicks + ticks125ms)    ' wait to create "sense" time-base


PRI distanceIn90ths(newPos) : n90ths
    if newPos == priorPos
        n90ths := 0
    elseif newPos < 0
        ' handle pos negative case
        if priorPos < 0
            '  -7 -> -9 = abs(-9) - abs(-7) = abs(2) = 2
            '  -11 -> -9 = abs(-9) - abs(-11) = abs(-2) = 2
            n90ths := abs(abs(newPos) - abs(priorPos))
        else
            '  9 -> -9 = 18 = abs(9) + abs(-9) = 18
            n90ths := abs(newPos) + abs(priorPos)
    else
        ' handle pos positive case
        if priorPos < 0
            ' -9 -> 6 = 6 + abs(-9) = 15
            ' -3 -> 6 = 6 + abs(-3) = 9
            n90ths := newPos + abs(priorPos)
        else
            ' 9 -> 6 = 6 - 9 = abs(-3) = 3
            ' 9 -> 12 = 12 - 9 = abs(3) = 3
            n90ths := abs(newPos - priorPos)
    'debug(`c 'pri=`sdec_(priorPos) pos=`sdec_(newPos) dist=`udec_(n90ths)' 13 10 update)       'update speed/distance display
    priorPos := newPos


DAT  {  DRIVER w/Motor Parameters  }
'

params      long                        ' motor-control parameters, reloaded every frame
offset_fwd  long    20 frac 360         ' 96 frac 360 (Doug's motor)
offset_rev  long    340 frac 360        ' 228 frac 360 (Doug's motor)
duty_min    long    100 << 4 #> OFFSET << 4
duty_max    long    PWMLIM << 4 <# PWMLIM << 4
duty_up     long    16
duty_dn     long    4
'
'
' PASM Driver Program
'
                org

driver          rdlong  x, ptra++                   ' get base pin
                rdlong  params_ptr_, ptra++         ' get parameters pointer
                add     ptra, #1*4                  ' point to return data, angle is at long index [-1]

                or      all_pins, x                 ' make all-pins variable

                mov     y, #0                       ' make single-pin variables
.pin            altd    y, #adc_u_i
                mov     0-0, x
                add     x, #1
                incmod  y, #15      wc
    if_nc       jmp     #.pin

                dirl    all_pins                    ' disable PWM and ADC pins for configuration

                wrpin   adc_modes+0, adc_u_i        ' set up ADC pins
                wrpin   adc_modes+0, adc_v_i
                wrpin   adc_modes+0, adc_w_i
                wrpin   adc_modes+0, adc_i

                wxpin   #10, adc_u_i                ' (#10 = 1024-clock / 11-bit conversion)
                wxpin   #10, adc_v_i
                wxpin   #10, adc_w_i
                wxpin   #10, adc_i

                wrpin   pwmn, pwm_u_l               ' set up PWM pins
                wrpin   pwmt, pwm_u_h
                wrpin   pwmn, pwm_v_l
                wrpin   pwmt, pwm_v_h
                wrpin   pwmn, pwm_w_l
                wrpin   pwmt, pwm_w_h

                wxpin   fram, pwm_u_l
                wxpin   fram, pwm_u_h
                wxpin   fram, pwm_v_l
                wxpin   fram, pwm_v_h
                wxpin   fram, pwm_w_l
                wxpin   fram, pwm_w_h

                dirh    all_pins                    ' enable ADC and PWM pins simultaneously for phase-locked operation

                dirl    hall_u                      ' remake HALL pins inputs (they were in-between ADC and PWM pins)
                dirl    hall_v
                dirl    hall_w

                mov     duty_, #0                   ' reset duty
                mov     pos_, #0                    ' reset pos
                mov     loop_ticks_, #0             ' just in case

.loop           getct   drvrSrtTicks
                call    #.next                      ' allow ADC rest period

                rdpin   vio_levels+0, adc_u_i       ' VIO samples done, read them
                rdpin   vio_levels+1, adc_v_i
                rdpin   vio_levels+2, adc_w_i
                rdpin   vio_levels+3, adc_i

                wrpin   adc_modes+2, adc_u_i        ' switch ADC to pin
                wrpin   adc_modes+2, adc_v_i
                wrpin   adc_modes+2, adc_w_i
                wrpin   adc_modes+2, adc_i

                call    #.next
                call    #.next                      ' allow ADC rest period

                rdpin   sense_u_, adc_u_i           ' pin samples done, read them
                rdpin   sense_v_, adc_v_i
                rdpin   sense_w_, adc_w_i
                rdpin   sense_i_, adc_i

                wrpin   adc_modes+0, adc_u_i        ' switch ADC to GIO calibration
                wrpin   adc_modes+0, adc_v_i
                wrpin   adc_modes+0, adc_w_i
                wrpin   adc_modes+0, adc_i

                call    #.next

                sub     vio_levels+0, gio_levels+0  ' compute (3300 << 11) / (vio_level - gio_level)
                sub     vio_levels+1, gio_levels+1
                sub     vio_levels+2, gio_levels+2
                sub     vio_levels+3, gio_levels+3

                qdiv    numerator, vio_levels+0
                qdiv    numerator, vio_levels+1
                qdiv    numerator, vio_levels+2
                qdiv    numerator, vio_levels+3

                getqx   scl_levels+0
                waitx   #4
                getqx   scl_levels+1
                waitx   #4
                getqx   scl_levels+2
                waitx   #4
                getqx   scl_levels+3

                sub     sense_u_, gio_levels+0      ' compute (quotient * (pin_level - gio_level)) >> 11
                muls    sense_u_, scl_levels+0
                sar     sense_u_, #11

                sub     sense_v_, gio_levels+1
                muls    sense_v_, scl_levels+1
                sar     sense_v_, #11

                sub     sense_w_, gio_levels+2
                muls    sense_w_, scl_levels+2
                sar     sense_w_, #11

                sub     sense_i_, gio_levels+3
                muls    sense_i_, scl_levels+3
                sar     sense_i_, #11

                call    #.next

                rdpin   gio_levels+0, adc_u_i       ' GIO samples done, read them
                rdpin   gio_levels+1, adc_v_i
                rdpin   gio_levels+2, adc_w_i
                rdpin   gio_levels+3, adc_i

                wrpin   adc_modes+1, adc_u_i        ' switch ADC to VIO calibration
                wrpin   adc_modes+1, adc_v_i
                wrpin   adc_modes+1, adc_w_i
                wrpin   adc_modes+1, adc_i

                call    #.next

                rdlong  angle_, ptra[-1]            ' get angle

                mov     y, duty_                    ' feed three CORDIC operations to get phase drive levels
                shr     y, #4
                mov     x, angle_
                qrotate y, x
                add     x, third
                qrotate y, x
                add     x, third
                qrotate y, x

                getqy   drive_u_                    ' get three CORDIC results
                getqy   drive_v_
                getqy   drive_w_

                mov     x, drive_u_                 ' get smallest drive level into x
                cmps    x, drive_v_ wc
    if_nc       mov     x, drive_v_
                cmps    x, drive_w_ wc
    if_nc       mov     x, drive_w_

                mov     y, drive_u_                 ' get largest drive level into y
                cmps    y, drive_v_ wc
    if_c        mov     y, drive_v_
                cmps    y, drive_w_ wc
    if_c        mov     y, drive_w_

                add     x, y                        ' sum smallest and largest, then divide by 2
                sar     x, #1

                sub     drive_u_, x                 ' subtract difference from drive levels
                sub     drive_v_, x
                sub     drive_w_, x

                add     drive_u_, bias              ' add center-bias and dead-time offsets to update PWMs
                add     drive_u_, #OFFSET
                wypin   drive_u_, pwm_u_l
                sub     drive_u_, #OFFSET
                wypin   drive_u_, pwm_u_h

                add     drive_v_, bias
                add     drive_v_, #OFFSET
                wypin   drive_v_, pwm_v_l
                sub     drive_v_, #OFFSET
                wypin   drive_v_, pwm_v_h

                add     drive_w_, bias
                add     drive_w_, #OFFSET
                wypin   drive_w_, pwm_w_l
                sub     drive_w_, #OFFSET
                wypin   drive_w_, pwm_w_h

                testp   hall_w      wc              ' read hall effect sensor
                rcl     hall_, #1
                testp   hall_v      wc
                rcl     hall_, #1
                testp   hall_u      wc
                rcl     hall_, #1
                and     hall_, #%111_111            ' (old << 3 | new) [ooo:nnn]
                altgb   hall_, #deltas              ' load byte deltas[hall_] -> [-1, 0, 1]
                getbyte x
                signx   x, #7                       ' sign-extend bit7
                add     pos_, x                     ' add to current pos_

                setq    #6-1                        ' load fresh parameter table
                rdlong  params_ptr_+1, params_ptr_

' verify the following code (3 lines)
                cmpm    angle_, angle2  wcz         ' if angle has changed, forward or reverse?
    if_nz       wrc     fwdrev
                mov     angle2, angle_

                testb   fwdrev, #0  wc              ' determine error
                bitc    hall_, #3
                and     hall_, #%1111
                alts    hall_, #hall_angles
                mov     err_, 0-0
    if_c        add     err_, offset_fwd_
    if_nc       add     err_, offset_rev_
                subr    err_, angle_
                sar     err_, #24
                bitl    hall_, #3

                abs     x, err_                     ' fault?
                cmp     x, #125     wc
    if_nc       wrlong  #1, ptra[12]
                sub     x, #256/6   wc              ' modulate duty
    if_nc       muls    x, duty_up_
    if_c        muls    x, duty_dn_
                sar     x, #8
                add     duty_, x
                fles    duty_, duty_max_            ' keep duty within limits
                fges    duty_, duty_min_

                getct   loop_ticks_                 ' how long was this iteration? send to host
                sub     loop_ticks_, drvrSrtTicks

                setq    #12-1                       ' write drive[3]/sense[4]/hall/pos/duty/err/drvTics to hub
                wrlong  drive_u_, ptra

                ' wait for end of 150 ticks to pass (since start of loop)
                '  fixing loop run-time to 150 ticks @200MHz clock (750nS / 1.33 MHz)
                mov     drvrEndTicks, drvrSrtTicks
                addct1  drvrEndTicks, #150
                waitct1
                jmp     #.loop                      ' main loop


.next           testp   adc_u_i     wc              ' wait for next ADC sample (6 samples = PWM frame)
    if_nc       jmp     #.next

    _ret_       akpin   adc_u_i


all_pins    long    15 << 6                 ' all-pins variable
pwmt        long    %000_000000_01_01000_0  ' PWM true
pwmn        long    %001_000000_01_01000_0  ' PWM not
fram        long    FRAME << 16 + 1         ' PWM frame setting
bias        long    FRAME / 2               ' PWM center-frame bias
third       long    1 FRAC 3                ' 120 degrees
numerator   long    3300 << 11              ' numerator for ADC calculations

adc_modes   long    p_adc_gio | p_adc       ' adc modes, by state
            long    p_adc_vio | p_adc
            long    p_adc_1x  | p_adc

deltas      byte    0, 0, 0, 0, 0, 0, 0, 0  ' Hall-effect-sensor position deltas from (old<<3 | new)
            byte    0, 0, 0,-1, 0, 1, 0, 0
            byte    0, 0, 0, 1, 0, 0,-1, 0
            byte    0, 1,-1, 0, 0, 0, 0, 0
            byte    0, 0, 0, 0, 0,-1, 1, 0
            byte    0,-1, 0, 0, 1, 0, 0, 0
            byte    0, 0, 1, 0,-1, 0, 0, 0
            byte    0, 0, 0, 0, 0, 0, 0, 0

hall_angles long    0           ' forward-direction table
            long    0 frac 6    '%001
            long    4 frac 6    '%010
            long    5 frac 6    '%011
            long    2 frac 6    '%100
            long    1 frac 6    '%101
            long    3 frac 6    '%110
            long    0
            long    0           ' reverse-direction table
            long    5 frac 6    '%001
            long    3 frac 6    '%010
            long    4 frac 6    '%011
            long    1 frac 6    '%100
            long    0 frac 6    '%101
            long    2 frac 6    '%110
            long    0


x           res     1           ' miscellaneous
y           res     1

drvrSrtTicks res 1
drvrEndTicks res 1

angle_      res 1
angle2      res 1
fwdrev      res 1

adc_u_i     res 1               ' single-pin variables
adc_v_i     res 1
adc_w_i     res 1
adc_x_i     res 1
adc_i       res 1
hall_u      res 1
hall_v      res 1
hall_w      res 1
pwm_u_l     res 1
pwm_u_h     res 1
pwm_v_l     res 1
pwm_v_h     res 1
pwm_w_l     res 1
pwm_w_h     res 1
pwm_x_l     res 1
pwm_x_h     res 1

gio_levels  res 4               ' ADC variables
vio_levels  res 4
scl_levels  res 4

params_ptr_ res 1               ' params_ptr must be followed by the six parameters
offset_fwd_ res 1
offset_rev_ res 1
duty_min_   res 1
duty_max_   res 1
duty_up_    res 1
duty_dn_    res 1

drive_u_    res 1               '   12 contiguous longs for return data structure
drive_v_    res 1
drive_w_    res 1
sense_u_    res 1
sense_v_    res 1
sense_w_    res 1
sense_i_    res 1
hall_       res 1
pos_        res 1
duty_       res 1
err_        res 1
loop_ticks_ res 1

CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2022 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
