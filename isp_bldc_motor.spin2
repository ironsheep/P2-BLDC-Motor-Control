'' =================================================================================================
''
''   File....... isp_bldc_motor.spin2
''   Purpose.... Object providing control interface for a single BLDC motor
''   Authors.... Stephen M Moraco
''               -- Copyright (c) 2022 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Feb 2022
''   Updated.... 9 Feb 2022
''
'' =================================================================================================

CON { Public Interface Constants }

  '  ID where the P2 Eval Motor Board is plugged in (Enum)
  #0[16], PINS_P0_P15, PINS_P16_P31, PINS_P32_P47

  ' Driver Distance-Units Enum
  #0, DDU_Unknown, DDU_IN, DDU_MM

  ' Driver Rotation-Units Enum
  #0, DRU_Unknown, DRU_DEGREES, DRU_ROTATIONS

  ' Driver Time-Unit Enum
  #0, DTU_Unknown, DTU_MILLISEC, DTU_SEC

  ' Driver Status Enum
  #0, DS_Unknown, DS_MOVING, DS_HOLDING, DS_OFF

CON { driver internal Constants}

  FRAME    = 1024 * 6 / 2       '6 ADC samples make 1 PWM frame, divide by two for triangle PWM
  OFFSET   = 40                ' enforced dead time in clock cycles (at 200_000_000)
  PWMLIM   = FRAME - OFFSET     'PWM duty hard limit

VAR { Data Structure for PASM Driver }
  ' remember these are zeroed at run time
  long  motorCog                            ' record the ID of cog we start
  long  senseCog                            ' record the ID of cog we start
  long  rpmIn10ths
  long  cntsInSec

  long  pinbase                             ' 1 long                must set initially
  long  params_ptr                          ' 1 long                must set initially
  long  angle                               ' 1 long                must set continually
  long  drive_u, drive_v, drive_w           ' 3 sequential longs    returns data continually
  long  sense_u, sense_v, sense_w, sense_i  ' 4 sequential longs    returns data continually
  long  hall, pos, duty, err                ' 4 sequential longs    returns data continually
  long  fault                               ' 1 sequential long     written to 1 on fault

PUB null()

'' This is not a top-level object

CON { --- Subsystem Configuration --- }

  INVALID_PIN_BASE = -1

PUB start(motorBasePin) : ok | legalBase
'' Specify motor control board connect location for this motor
  legalBase := motorBasePin
  ' ensure we only use legal values
  CASE motorBasePin
    PINS_P0_P15 :
    PINS_P16_P31 :
    PINS_P32_P47 :
    OTHER :
        legalBase := INVALID_PIN_BASE

  ' if legal base-pin then start cog
  if legalBase <> INVALID_PIN_BASE
    pinbase := motorBasePin     ' record base pin number
    params_ptr := @params       ' point to driver variables

    motorCog := coginit(newcog, @driver, @pinbase) + 1
    ok := (motorCog <> 0) ? true : false

    senseCog := cogspin(newcog, taskPostionSense(), @taskStack)
    if senseCog == -1    ' did fail?
        debug("!! ERROR filed to start Position Sense task")

PUB stop()
'' Stop cog and release pins assigned to this motor

    if motorCog
        cogstop(motorCog - 1)
        motorCog := 0

    ' Bottom 8 pins are sensed, top 8 are driven, so clear only the top 8
    pinclear(pinbase+8 addpins 7)


PUB setAcceleration(rate)
'' Limit Acceleration to {rate} where {rate} is [??? - ???] mm/s squared (default is ??? mm/s squared)

PUB setMaxSpeed(speed)
'' Limit top-speed to {speed} where {speed} is [??? - ???] mm/s (default is ??? mm/s)

PUB setMaxSpeedForDistance(speed)
'' Limit top-speed of driveDistance() operations to {speed} where {speed} is [??? - ???] mm/s (default is ??? mm/s)

PUB calibrate()
'' (we may need this?)

PUB holdAtStop(bEnable)
'' Informs the motor control cog to actively hold postiion (bEnable=true) or coast (bEnable=false) at end of motion

PUB resetTracking()
'' Resets the position tracking values returned by getDistance() and getRotations()

CON { --- Subsystem Control --- }

PUB driveForDistance(distance, distanceUnits)
'' Control the forward direction of this motor using the {distance} and {distanceUnits} inputs.
'' Turn the motor on then turn it off again after it reaches the specified {distance} in {distanceUnits} [DDU_IN or DDU_MM].
'' AFFECTED BY:  setAcceleration(), setMaxSpeedForDistance(), holdAtStop()

PUB driveAtPower(power) | limitPwr
'' Control the speed and direction of this motor using the {power, [(-100) to 100]} input.
'' Turns the motor on at {power}.
'' AFFECTED BY:  setAcceleration(), setMaxSpeed(), holdAtStop()
    limitPwr :=  -100 #> power <# 100

PUB stopAfterRotation(rotationCount, rotationUnits)
'' Stops the motor after it reaches {rotationCount} of {rotationUnits} [DRU_DEGREES, DRU_ROTATIONS].
'' USE WITH:  driveDirection(), drive()

PUB stopAfterDistance(distance, distanceUnits)
'' Stops the motor after either it reaches {distance} specified in {distanceUnits} [DDU_IN or DDU_MM].
'' USE WITH:  driveDirection(), drive()

PUB stopAfterTime(time, timeUnits)
'' Stops the motor, after {time} specified in {timeUnits} [DTU_IN_MILLISEC or DTU_IN_SEC] has elapsed.
'' USE WITH:  driveDirection(), drive()

PUB stopMotor()
'' Stops the motor, killing any motion that was still in progress
''  AFFECTED BY:holdAtStop()

CON { --- Subsystem Status --- }

PUB getDistance(distanceUnits) : distanceInUnits
'' Returns the distance in {distanceUnits} [DDU_IN or DDU_MM] travelled by this motor since last reset

PUB getRotationCount(rotationUnits) : rotationCount
'' Returns accumulated {rotationCount} in {rotationUnits} [DRU_DEGREES, DRU_ROTATIONS], since last reset, for this motor.

PUB getStatus() : eStatus
'' Returns status of motor drive state for this motor: enumerated constant: DS_MOVING, DS_HOLDING or DS_OFF
    eStatus := DS_OFF   ' force this for now...


CON { --- PRIVATE Utility Methods --- }


CON { --- The Motor driver --- }

  STABILIZE_LOOP_CT = 2000

PUB testMotor() | priorHall, angleIncr, faultHoldoffCtr
'' invoke start() before invoke of testMotor()
  debug(`logic l title 'Hall Effect' pos 650 500 'Hall' 3)

  debug(`term t title 'Status' pos 650 650 size 30 1 textsize 20 update)

  debug(`term v title 'Distance/Speed' pos 650 30 size 70 5 textsize 12 update)

  debug(`term i title 'Instrument' pos 650 165 size 70 5 textsize 12 update)

  debug(`scope r title 'Duty and Error' pos 363 439 size 256 256 samples 256 rate 50)
  debug(`r 'Duty' 0 `(PWMLIM<<4) 256 0)
  debug(`r 'Error' -128 128 256 0 15)

  debug(`scope s title 'Voltages' pos 105 60 size 512 300 samples 256 rate 256)
  debug(`s 'U' 0 `(FRAME) 128 170)
  debug(`s 'V' 0 `(FRAME) 128 170)
  debug(`s 'W' 0 `(FRAME) 128 170)
  debug(`s 'Iu' 0 2000 128 70)
  debug(`s 'Iv' 0 2000 128 70)
  debug(`s 'Iw' 0 2000 128 70)
  debug(`s 'P' 0 100 128 10)

  repeat

    if hall <> priorHall                    'if hall effect changed, update logic display
      debug(`l `ubin_byte_(hall))
      priorHall := hall

    debug(`t 0 '`sdec(duty, pos)' update)       'update terminal and scope displays
    debug(`r `sdec_(duty, err))
    debug(`s `sdec_long_array_(@drive_u,3) `sdec_long_array_(@sense_u,4))
    debug(`v 0 'cnts=`udec_(cntsInSec) rpm=`udec_(rpm).`udec_(rpmTenths)' update)       'update speed/distance display

    'angle += 10_000_000                                'update angle to turn motor
    angle += qsin(1<<28, angleIncr += 100000, 0)        'update angle to turn motor

    if faultHoldoffCtr++ < STABILIZE_LOOP_CT            ' if still getting sense of motor hold-off faults
      fault~
    if fault and faultHoldoffCtr > STABILIZE_LOOP_CT    ' if fault, shut down
      debug(`t 0 'FAULT' update)
      stop()
      repeat    ' and lock here!

    waitus(500)    ' wait to create time base (500 faults motor w/angle!!)

CON { TASK position tracking }

  STACK_SIZE_LONGS = 48

DAT
    taskStack       long    0[STACK_SIZE_LONGS]

PRI taskPostionSense()
  msTicks := clkfreq / 1_000
'  usTicks := clkfreq / 1_000_000

  repeat
    preTicks := getct()
    cntsInSec := distanceIn90ths(pos) * 8
    rpmIn10ths := (cntsInSec * 60) / 9
    rpm := rpmIn10ths / 10
    rpmTenths := rpmIn10ths // 10
    'deltaTicks := getct() - preTicks
    'debug(`i 0 'tic Delta=`udec_(deltaTicks), ms=`udec_(msTicks), us=`udec_(usTicks)' update)
    ' wait until next 250msec period
    WAITCT(preTicks + (msTicks * 125))    ' wait to create sense time base

VAR { misc. vars }

 '   long usTicks
    long msTicks
    long preTicks
    long deltaTicks
    long priorPos
    long rpm
    long rpmTenths

PRI distanceIn90ths(newPos) : n90ths
    if newPos == priorPos
        n90ths := 0
    elseif newPos < 0
        ' handle pos negative case
        if priorPos < 0
            '  -7 -> -9 = abs(-9) - abs(-7) = abs(2) = 2
            '  -11 -> -9 = abs(-9) - abs(-11) = abs(-2) = 2
            n90ths := abs(abs(newPos) - abs(priorPos))
        else
            '  9 -> -9 = 18 = abs(9) + abs(-9) = 18
            n90ths := abs(newPos) + abs(priorPos)
    else
        ' handle pos positive case
        if priorPos < 0
            ' -9 -> 6 = 6 + abs(-9) = 15
            ' -3 -> 6 = 6 + abs(-3) = 9
            n90ths := newPos + abs(priorPos)
        else
            ' 9 -> 6 = 6 - 9 = abs(-3) = 3
            ' 9 -> 12 = 12 - 9 = abs(3) = 3
            n90ths := abs(newPos - priorPos)
    'debug(`v 'pri=`sdec_(priorPos) pos=`sdec_(newPos) dist=`udec_(n90ths)' 13 10 update)       'update speed/distance display
    priorPos := newPos


DAT  {  DRIVER w/Motor Parameters  }
'

params      long                        ' motor-control parameters, reloaded every frame
offset_fwd  long    20 frac 360         ' 96 frac 360 (Doug's motor)
offset_rev  long    340 frac 360        ' 228 frac 360 (Doug's motor)
duty_min    long    100 << 4 #> OFFSET << 4
duty_max    long    PWMLIM << 4 <# PWMLIM << 4
duty_up     long    16
duty_dn     long    4
'
'
' PASM Driver Program
'
                org

driver          rdlong  x, ptra++                   ' get base pin
                rdlong  params_ptr_, ptra++         ' get parameters pointer
                add     ptra, #1*4                  ' point to return data, angle is at long index [-1]

                or      all_pins, x                 ' make all-pins variable

                mov     y, #0                       ' make single-pin variables
.pin            altd    y, #adc_u_i
                mov     0-0, x
                add     x, #1
                incmod  y, #15      wc
    if_nc       jmp     #.pin

                dirl    all_pins                    ' disable PWM and ADC pins for configuration

                wrpin   adc_modes+0, adc_u_i        ' set up ADC pins
                wrpin   adc_modes+0, adc_v_i
                wrpin   adc_modes+0, adc_w_i
                wrpin   adc_modes+0, adc_i

                wxpin   #10, adc_u_i                ' (#10 = 1024-clock / 11-bit conversion)
                wxpin   #10, adc_v_i
                wxpin   #10, adc_w_i
                wxpin   #10, adc_i

                wrpin   pwmn, pwm_u_l               ' set up PWM pins
                wrpin   pwmt, pwm_u_h
                wrpin   pwmn, pwm_v_l
                wrpin   pwmt, pwm_v_h
                wrpin   pwmn, pwm_w_l
                wrpin   pwmt, pwm_w_h

                wxpin   fram, pwm_u_l
                wxpin   fram, pwm_u_h
                wxpin   fram, pwm_v_l
                wxpin   fram, pwm_v_h
                wxpin   fram, pwm_w_l
                wxpin   fram, pwm_w_h

                dirh    all_pins                    ' enable ADC and PWM pins simultaneously for phase-locked operation

                dirl    hall_u                      ' remake HALL pins inputs (they were in-between ADC and PWM pins)
                dirl    hall_v
                dirl    hall_w

                mov     duty_, #0                   ' reset duty
                mov     pos_, #0                    ' reset pos

.loop           call    #.next                      ' allow ADC rest period

                rdpin   vio_levels+0, adc_u_i       ' VIO samples done, read them
                rdpin   vio_levels+1, adc_v_i
                rdpin   vio_levels+2, adc_w_i
                rdpin   vio_levels+3, adc_i

                wrpin   adc_modes+2, adc_u_i        ' switch ADC to pin
                wrpin   adc_modes+2, adc_v_i
                wrpin   adc_modes+2, adc_w_i
                wrpin   adc_modes+2, adc_i

                call    #.next
                call    #.next                      ' allow ADC rest period

                rdpin   sense_u_, adc_u_i           ' pin samples done, read them
                rdpin   sense_v_, adc_v_i
                rdpin   sense_w_, adc_w_i
                rdpin   sense_i_, adc_i

                wrpin   adc_modes+0, adc_u_i        ' switch ADC to GIO calibration
                wrpin   adc_modes+0, adc_v_i
                wrpin   adc_modes+0, adc_w_i
                wrpin   adc_modes+0, adc_i

                call    #.next

                sub     vio_levels+0, gio_levels+0  ' compute (3300 << 11) / (vio_level - gio_level)
                sub     vio_levels+1, gio_levels+1
                sub     vio_levels+2, gio_levels+2
                sub     vio_levels+3, gio_levels+3

                qdiv    numerator, vio_levels+0
                qdiv    numerator, vio_levels+1
                qdiv    numerator, vio_levels+2
                qdiv    numerator, vio_levels+3

                getqx   scl_levels+0
                waitx   #4
                getqx   scl_levels+1
                waitx   #4
                getqx   scl_levels+2
                waitx   #4
                getqx   scl_levels+3

                sub     sense_u_, gio_levels+0      ' compute (quotient * (pin_level - gio_level)) >> 11
                muls    sense_u_, scl_levels+0
                sar     sense_u_, #11

                sub     sense_v_, gio_levels+1
                muls    sense_v_, scl_levels+1
                sar     sense_v_, #11

                sub     sense_w_, gio_levels+2
                muls    sense_w_, scl_levels+2
                sar     sense_w_, #11

                sub     sense_i_, gio_levels+3
                muls    sense_i_, scl_levels+3
                sar     sense_i_, #11

                call    #.next

                rdpin   gio_levels+0, adc_u_i       ' GIO samples done, read them
                rdpin   gio_levels+1, adc_v_i
                rdpin   gio_levels+2, adc_w_i
                rdpin   gio_levels+3, adc_i

                wrpin   adc_modes+1, adc_u_i        ' switch ADC to VIO calibration
                wrpin   adc_modes+1, adc_v_i
                wrpin   adc_modes+1, adc_w_i
                wrpin   adc_modes+1, adc_i

                call    #.next

                rdlong  angle_, ptra[-1]            ' get angle

                mov     y, duty_                    ' feed three CORDIC operations to get phase drive levels
                shr     y, #4
                mov     x, angle_
                qrotate y, x
                add     x, third
                qrotate y, x
                add     x, third
                qrotate y, x

                getqy   drive_u_                    ' get three CORDIC results
                getqy   drive_v_
                getqy   drive_w_

                mov     x, drive_u_                 ' get smallest drive level into x
                cmps    x, drive_v_ wc
    if_nc       mov     x, drive_v_
                cmps    x, drive_w_ wc
    if_nc       mov     x, drive_w_

                mov     y, drive_u_                 ' get largest drive level into y
                cmps    y, drive_v_ wc
    if_c        mov     y, drive_v_
                cmps    y, drive_w_ wc
    if_c        mov     y, drive_w_

                add     x, y                        ' sum smallest and largest, then divide by 2
                sar     x, #1

                sub     drive_u_, x                 ' subtract difference from drive levels
                sub     drive_v_, x
                sub     drive_w_, x

                add     drive_u_, bias              ' add center-bias and dead-time offsets to update PWMs
                add     drive_u_, #OFFSET
                wypin   drive_u_, pwm_u_l
                sub     drive_u_, #OFFSET
                wypin   drive_u_, pwm_u_h

                add     drive_v_, bias
                add     drive_v_, #OFFSET
                wypin   drive_v_, pwm_v_l
                sub     drive_v_, #OFFSET
                wypin   drive_v_, pwm_v_h

                add     drive_w_, bias
                add     drive_w_, #OFFSET
                wypin   drive_w_, pwm_w_l
                sub     drive_w_, #OFFSET
                wypin   drive_w_, pwm_w_h

                testp   hall_w      wc              ' read hall effect sensor
                rcl     hall_, #1
                testp   hall_v      wc
                rcl     hall_, #1
                testp   hall_u      wc
                rcl     hall_, #1
                and     hall_, #%111_111            ' (old << 3 | new) [ooo:nnn]
                altgb   hall_, #deltas              ' load byte deltas[hall_] -> [-1, 0, 1]
                getbyte x
                signx   x, #7                       ' sign-extend bit7
                add     pos_, x                     ' add to current pos_

                setq    #6-1                        ' load fresh parameter table
                rdlong  params_ptr_+1, params_ptr_

' verify the following code (3 lines)
                cmpm    angle_, angle2  wcz         ' if angle has changed, forward or reverse?
    if_nz       wrc     fwdrev
                mov     angle2, angle_

                testb   fwdrev, #0  wc              ' determine error
                bitc    hall_, #3
                and     hall_, #%1111
                alts    hall_, #hall_angles
                mov     err_, 0-0
    if_c        add     err_, offset_fwd_
    if_nc       add     err_, offset_rev_
                subr    err_, angle_
                sar     err_, #24
                bitl    hall_, #3

                abs     x, err_                     ' fault?
                cmp     x, #125     wc
    if_nc       wrlong  #1, ptra[11]
                sub     x, #256/6   wc              ' modulate duty
    if_nc       muls    x, duty_up_
    if_c        muls    x, duty_dn_
                sar     x, #8
                add     duty_, x
                fles    duty_, duty_max_            ' keep duty within limits
                fges    duty_, duty_min_

                setq    #11-1                       ' write drive[3]/sense[4]/hall/pos/duty/err to hub
                wrlong  drive_u_, ptra

                jmp     #.loop                      ' main loop


.next           testp   adc_u_i     wc              ' wait for next ADC sample (6 samples = PWM frame)
    if_nc       jmp     #.next

    _ret_       akpin   adc_u_i


all_pins    long    15 << 6                 ' all-pins variable
pwmt        long    %000_000000_01_01000_0  ' PWM true
pwmn        long    %001_000000_01_01000_0  ' PWM not
fram        long    FRAME << 16 + 1         ' PWM frame setting
bias        long    FRAME / 2               ' PWM center-frame bias
third       long    1 FRAC 3                ' 120 degrees
numerator   long    3300 << 11              ' numerator for ADC calculations

adc_modes   long    p_adc_gio | p_adc       ' adc modes, by state
            long    p_adc_vio | p_adc
            long    p_adc_1x  | p_adc

deltas      byte    0, 0, 0, 0, 0, 0, 0, 0  ' Hall-effect-sensor position deltas from (old<<3 | new)
            byte    0, 0, 0,-1, 0, 1, 0, 0
            byte    0, 0, 0, 1, 0, 0,-1, 0
            byte    0, 1,-1, 0, 0, 0, 0, 0
            byte    0, 0, 0, 0, 0,-1, 1, 0
            byte    0,-1, 0, 0, 1, 0, 0, 0
            byte    0, 0, 1, 0,-1, 0, 0, 0
            byte    0, 0, 0, 0, 0, 0, 0, 0

hall_angles long    0           ' forward-direction table
            long    0 frac 6    '%001
            long    4 frac 6    '%010
            long    5 frac 6    '%011
            long    2 frac 6    '%100
            long    1 frac 6    '%101
            long    3 frac 6    '%110
            long    0
            long    0           ' reverse-direction table
            long    5 frac 6    '%001
            long    3 frac 6    '%010
            long    4 frac 6    '%011
            long    1 frac 6    '%100
            long    0 frac 6    '%101
            long    2 frac 6    '%110
            long    0


x           res     1           ' miscellaneous
y           res     1

angle_      res 1
angle2      res 1
fwdrev      res 1

adc_u_i     res 1               ' single-pin variables
adc_v_i     res 1
adc_w_i     res 1
adc_x_i     res 1
adc_i       res 1
hall_u      res 1
hall_v      res 1
hall_w      res 1
pwm_u_l     res 1
pwm_u_h     res 1
pwm_v_l     res 1
pwm_v_h     res 1
pwm_w_l     res 1
pwm_w_h     res 1
pwm_x_l     res 1
pwm_x_h     res 1

gio_levels  res 4               ' ADC variables
vio_levels  res 4
scl_levels  res 4

params_ptr_ res 1               ' params_ptr must be followed by the six parameters
offset_fwd_ res 1
offset_rev_ res 1
duty_min_   res 1
duty_max_   res 1
duty_up_    res 1
duty_dn_    res 1

drive_u_    res 1               '   11 contiguous longs for return data structure
drive_v_    res 1
drive_w_    res 1
sense_u_    res 1
sense_v_    res 1
sense_w_    res 1
sense_i_    res 1
hall_       res 1
pos_        res 1
duty_       res 1
err_        res 1


CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2022 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
