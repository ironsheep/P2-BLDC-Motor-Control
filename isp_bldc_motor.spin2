'' =================================================================================================
''
''   File....... isp_bldc_motor.spin2
''   Purpose.... Object providing control interface for a single BLDC motor
''   Authors.... Stephen M Moraco
''               -- Copyright (c) 2022 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Feb 2022
''   Updated.... 14 Mar 2022
''
'' =================================================================================================

CON { Public Interface Constants }

    '  ID where the P2 Eval Motor Board is plugged in (Enum)
    '    (Names of supported PinGroups)
    #0[16], PINS_P0_P15, PINS_P16_P31, PINS_P32_P47
    ' return value when user makes bad choice
    INVALID_PIN_BASE = -1

    ' Names of supported voltages
    '  Lipo battery sizes: 2s-7.4v, 3s-11.1v, 4s-14.8v, 5s-18.5v, 6s-22.2v, 7s-25.9v
    #0, PWR_Unknown, PWR_6V, PWR_7p4V, PWR_11p1V, PWR_12V, PWR_14p8V, PWR_18p5V, PWR_22p2V, PWR_24V
    ' return value when user makes bad choice
    INVALID_VOLTAGE = -1

    VALUE_NOT_SET = -1

    ' Driver Distance-Units Enum: (Millimeters, Centimeters, Inches, Feet, Meters, Kilometers, Miles)
    #0, DDU_Unknown, DDU_MM, DDU_CM, DDU_IN, DDU_FT, DDU_M, DDU_KM, DDU_MI

    ' Driver Rotation-Units Enum:
    #0, DRU_Unknown, DRU_HALL_TICKS, DRU_DEGREES, DRU_ROTATIONS

    ' Driver Time-Unit Enum:
    #0, DTU_Unknown, DTU_MILLISEC, DTU_SEC

    ' Driver Status Enum:
    #10, DS_Unknown, DS_MOVING, DS_HOLDING, DS_OFF

    ' Driver Control Stop-State Enum:
    #0, SM_Unknown, SM_FLOAT, SM_BRAKE


OBJ { objects / constants included by this object }

    user        :   "isp_bldc_motor_userconfig"     ' driver configuration
    distConv    :   "isp_dist_utils"                ' distance conversion utils

CON { test pins for LA measurement }

    ' PIN_8 - PIN_15
    TEST_BASE_PIN = 8
    TEST_ALL_PINS = TEST_BASE_PIN addpins 7
    TEST_PIN_OUTER_LOOP = TEST_BASE_PIN + 0       ' LA grey
    TEST_PIN_SENSE_LOOP = TEST_BASE_PIN + 1       ' LA red
    TEST_PIN_DRIVER_LOOP = TEST_BASE_PIN + 2            ' LA Yellow
    TEST_PIN_DRIVER_TMR = TEST_BASE_PIN + 3             ' LA Green

DAT { misc time constants / debug enable }

    ticks125ms  long    0                     ' time constants based on CPU freq
    ticks500us  long    0                     '
    ticks750us  long    0                     '
    ticks800us  long    0                     '
    ticks1ms    long    0                     '
    ticks1us    long    0                     '

    useDebug   long    FALSE
    showHDMIDebug   long    FALSE

PUB null()

'' This is not a top-level object

PUB start(eMotorBasePin, eMotorVoltage) : ok | legalBase
'' Specify motor control board connect location for this motor and start the driver
        ' setup runtime constants
    ticks1ms   := (CLKFREQ / 1_000)
    ticks1us   := (CLKFREQ / 1_000_000)
    ticks125ms := ticks1ms * 125
    ticks500us := (ticks1ms * 500) / 1_000  ' phrased this way for better result
    ticks750us := (ticks1ms * 750) / 1_000  ' phrased this way for better result
    ticks800us := (ticks1ms * 800) / 1_000  ' phrased this way for better result

    ' setup driver parameters based on clock rate
    ctrl_ticks := ticks500us
    dead_gap    := (ticks1us * 260) / 1_000    ' 260 of these made into "value nS"
    duty_min    := 100 << 4 #> dead_gap << 4
    pwm_limit   := FRAME - dead_gap     'PWM duty hard limit 1/2 freq of PWM
    duty_max    := pwm_limit << 4 <# pwm_limit << 4

    loop_ticks := 0
    minDrvTics := 65535
    drv_state := DS_Unknown

    tvMaxMmPerSec_x10 := 0
    tvMaxFps_x10 := 0
    tvMaxMPH_x10 := 0
    tvMaxkPH_x10 := 0

    userSelectedVolts := VALUE_NOT_SET    ' ensure we don't drive motor unles we know the users' voltage!

    debug("* init values ", udec_long(dead_gap), udec_long(ctrl_ticks), udec_long(duty_min), udec_long(pwm_limit), udec_long(duty_max))


    circInMM_x10 := distConv.circInMMforDiaInInchFloat(user.MOTOR_DIA_IN_INCH)
    tickInMM_x10 := circInMM_x10 / 90

    confgurePowerLimits(user.DRIVE_VOLTAGE)

    ' ensure we only use legal values
    legalBase := eMotorBasePin
    CASE eMotorBasePin
        PINS_P0_P15 :
        PINS_P16_P31 :
        PINS_P32_P47 :
        OTHER :
            legalBase := INVALID_PIN_BASE

    ' if legal base-pin then start cog
    if legalBase <> INVALID_PIN_BASE
        pinbase := legalBase        ' record base pin number
        params_ptr := @params       ' point to driver variables
        setTargetAccel(0)           ' do NOT move at startup

        ok := motorCog := coginit(NEWCOG, @driver, @pinbase) + 1
        if motorCog == 0    ' did fail?
            debug("!! ERROR filed to start Motor Control task")

PUB startSenseCog() : ok
'' Start the single motor sense task (tracks position of motor, distance travelled, etc.)
    ok := senseCog := cogspin(NEWCOG, taskPostionSense(), @taskStack) + 1
    if senseCog == 0    ' did fail?
        debug("!! ERROR filed to start Position Sense task")

PUB stop()
'' Stop cogs and release pins assigned to this motor

    if motorCog     ' stop motor drive
        cogstop(motorCog - 1)
        motorCog := 0

    ' Bottom 8 pins are sensed, top 8 are driven, so clear only the top 8
    pinclear(pinbase+8 addpins 7)

    if senseCog     ' stop motor reads
        cogstop(senseCog - 1)
        senseCog := 0

VAR { -- user request values -- }

    LONG    userSelectedVolts     ' remember the value specified by the user
    ' limits based on user voltage
    LONG    minFwdIncreAtPwr
    LONG    maxFwdIncreAtPwr
    LONG    minRevIncreAtPwr
    LONG    maxRevIncreAtPwr
    ' stop point in time based on passing mSec or tick counts
    LONG    motorStopMSecs      ' stop motor when we've passed this time in milliseconds
    LONG    motorStopHallTicks  ' stop motor when we've passed this tick count
    LONG    motorPower          ' remember last power requested

PUB setAcceleration(rate)
'' NOT WORKING: Limit Acceleration to {rate} where {rate} is [??? - ???] mm/s squared (default is ??? mm/s squared)

PUB setMaxSpeed(speed)
'' NOT WORKING: Limit top-speed to {speed} where {speed} is [??? - ???] mm/s (default is ??? mm/s)

PUB setMaxSpeedForDistance(speed)
'' NOT WORKING: Limit top-speed of driveDistance() operations to {speed} where {speed} is [??? - ???] mm/s (default is ??? mm/s)

PUB calibrate()
'' NOT WORKING: (we may need this?)

PUB holdAtStop(bEnable)
'' Informs the motor control cog to actively hold position (bEnable=true) or coast (bEnable=false) at end of motion
    stop_mode := (bEnable) ? SM_BRAKE : SM_FLOAT

PUB resetTracking()
'' Resets the position tracking values returned by getDistance() and getRotations()
    posTrkHallTicks := 0    ' reset all of our trackers (they are incremented in sensor loop)

CON { --- Subsystem Control --- }

PUB driveForDistance(distance, distanceUnits)
'' NOT WORKING: Control the forward direction of this motor using the {distance} and {distanceUnits} inputs.
'' Turn the motor on then turn it off again after it reaches the specified {distance} in {distanceUnits} [DDU_IN or DDU_MM].
'' AFFECTED BY:  setAcceleration(), setMaxSpeedForDistance(), holdAtStop()

PUB driveAtPower(power) | limitPwr, motorIncre
'' Control the speed and direction of this motor using the {power, [(-100) to 100]} input.
'' Turns the motor on at {power}.
'' AFFECTED BY:  setAcceleration(), setMaxSpeed(), holdAtStop()
    limitPwr :=  -100 #> power <# 100
    if limitPwr <> power
        debug("! WARNING: driveAtPower() power out of range (corrected):", udec_long(power), " - must be [-100 to +100]")
    debug("driveAtPower() ", sdec_long(limitPwr))
    motorPower := limitPwr
    motorIncre := incrementForPower(limitPwr)
    setTargetAccel(motorIncre)

PUB stopAfterRotation(nRotationCount, eRotationUnits)
'' Stops the motor after it reaches {rotationCount} of {rotationUnits} [DRU_HALL_TICKS, DRU_DEGREES, or DRU_ROTATIONS].
'' USE WITH:  driveAtPower()
'' Will ABORT if {rotationCount} < 1
    if nRotationCount < 1
        debug("! ERROR: invalid RotationCount Value:", udec_long(nRotationCount), " - must be > 0!")
        ' FIXME: UNDONE should be more than ticks needed for spin-up/down ramps!!!
        abort

    ' FIXME: UNDONE convert this to use runtime values based on user specified wheel size ( we assume wheel is 90 tics! )

    ' FIXME: UNDONE remove # ticks for spin-up/down ramps!!!

    ' convert rotation info to ticks (will stop at ticks limit)
    motorStopHallTicks := 0
    case eRotationUnits
        DRU_HALL_TICKS:
            motorStopHallTicks := nRotationCount
        DRU_DEGREES:
            ' ticks = degrees / 4
            motorStopHallTicks := nRotationCount / 4
        DRU_ROTATIONS:
            ' ticks = rotations * 90
            motorStopHallTicks := nRotationCount * 90
        other:
            debug("! ERROR: invalid rotationUnits Value:", udec_long(eRotationUnits))
            abort

PUB stopAfterDistance(nDistance, eDistanceUnits) | fValue
'' Stops the motor after either it reaches {distance} specified in {distanceUnits} [DDU_MM, DDU_CM, DDU_IN, DDU_FT, DDU_M].
'' USE WITH:  driveAtPower()
'' Will ABORT if {distance} < 1
    if nDistance < 1
        debug("! ERROR: invalid Distance Value:", udec_long(nDistance), " - must be > 0!")
        ' FIXME: UNDONE should be more than ticks needed for spin-up/down ramps!!!
        abort

    ' FIXME: UNDONE convert this to use runtime values based on user specified wheel size ( we assume wheel is 90 tics! )

    ' FIXME: UNDONE remove time needed for spin-up/down ramps!!!

    ' convert distance to ticks (will stop at ticks limit)
    case eDistanceUnits
        DDU_MM:
            motorStopHallTicks := (nDistance * 10) / tickInMM_x10
        DDU_CM:
            motorStopHallTicks := (nDistance * 10 * 10) / tickInMM_x10
        DDU_IN:
            fValue := distConv.fIn2mm(nDistance)
            motorStopHallTicks := trunc(fValue *. 10.0) / tickInMM_x10
        DDU_FT:
            fValue := distConv.fIn2mm(nDistance * 12)
            motorStopHallTicks := trunc(fValue *. 10.0) / tickInMM_x10
        DDU_M:
            motorStopHallTicks := (nDistance * 100 * 10) / tickInMM_x10
        other:
            debug("! ERROR: invalid distanceUnits Stop Value:", udec_long(eDistanceUnits))
            abort

PUB stopAfterTime(nTime, eTimeUnits) | timeNow
'' Stops the motor, after {time} specified in {timeUnits} [DTU_MILLISEC or DTU_SEC] has elapsed.
'' USE WITH:  driveAtPower()
'' Will ABORT if {time} < 1
    if nTime < 1
        debug("! ERROR: invalid nTime Value:", udec_long(nTime), " - must be > 0!")
        ' FIXME: UNDONE should be more than time needed for spin-up/down ramps!!!
        abort

    case eTimeUnits
        DTU_MILLISEC:
        DTU_SEC:
        other:
            debug("! ERROR: invalid timeUnits Value:", udec_long(eTimeUnits))
            abort

    ' FIXME: UNDONE remove time needed for spin-up/down ramps!!!

    if eTimeUnits == DTU_SEC
        timeNow := getms()
        motorStopMSecs := timeNow + (nTime * 1_000)
    else
        timeNow := getms()
        motorStopMSecs := timeNow + nTime

    if motorStopMSecs > 0
        debug("* stop motor at ", udec_long(motorStopMSecs), ", now: ", udec_long(timeNow))

PUB stopMotor()
'' Stops the motor, killing any motion that was still in progress
''  AFFECTED BY:holdAtStop()
    setTargetAccel(0)

CON { --- Subsystem Status --- }

PUB getDistance(eDistanceUnits) : nDistanceInUnits | fMMpTick, fValue
'' Returns the distance in {distanceUnits} [DDU_MM, DDU_CM, DDU_IN, DDU_FT, DDU_M, DDU_KM, DDU_MI] travelled by this motor since last reset
    fMMpTick := float(circInMM_x10) /. 90.0 /. 10.0
    case eDistanceUnits
        DDU_MM:
            nDistanceInUnits := trunc(float(posTrkHallTicks) *. fMMpTick)
        DDU_CM:
            nDistanceInUnits := trunc(float(posTrkHallTicks) *. fMMpTick /. 10.0)
        DDU_IN:
            fValue := distConv.fMm2inFloat(float(posTrkHallTicks) *. fMMpTick)
            nDistanceInUnits := trunc(fValue +. 0.5)    ' rounded
        DDU_FT:
            fValue := distConv.fMm2inFloat(float(posTrkHallTicks) *. fMMpTick)
            nDistanceInUnits := trunc(fValue /. 12.0 +. 0.5)    ' in FT, rounded
        DDU_M:
            fValue := float(posTrkHallTicks) *. fMMpTick
            nDistanceInUnits := trunc(fValue /. 1000.0)    ' in M
        DDU_MI:
            fValue := distConv.fMm2inFloat(float(posTrkHallTicks) *. fMMpTick)
            nDistanceInUnits := trunc(fValue /. 5280.0 /. 12.0)    ' in MI
        DDU_KM:
            fValue := float(posTrkHallTicks) *. fMMpTick
            nDistanceInUnits := trunc(fValue /. 1000.0 /. 1000.0)    ' in kM
        other:
            debug("! ERROR: invalid distanceUnits Value:", udec_long(eDistanceUnits))
            abort

PUB getRotationCount(eRotationUnits) : rotationCount
'' Returns accumulated {rotationCount} in {rotationUnits} [DRU_DEGREES, DRU_ROTATIONS, or DRU_HALL_TICKS], since last reset, for this motor.
    rotationCount := 0
    case eRotationUnits
        DRU_HALL_TICKS:
            rotationCount := motorStopHallTicks
        DRU_DEGREES:
            ' degrees = ticks * 4
            rotationCount := motorStopHallTicks * 4
        DRU_ROTATIONS:
            ' rotations = ticks / 90
            rotationCount := motorStopHallTicks / 90
        other:
            debug("! ERROR: invalid rotationUnits Value:", udec_long(eRotationUnits))
            abort

PUB getPower() : nPower
'' Returns the last specified power value [-100 thru +100] for motor (will be zero if the motor is stopped).
    nPower := motorPower

PUB getStatus() : eStatus
'' Returns status of motor drive state for this motor: enumerated constant: DS_Unknown, DS_MOVING, DS_HOLDING, or DS_OFF
    if isStopped()
        if stop_mode == SM_BRAKE
            eStatus := DS_HOLDING
        elseif stop_mode == SM_FLOAT
            eStatus := DS_OFF
    elseif isReady()
        eStatus := DS_MOVING
    else
        eStatus := DS_Unknown

PUB isReady() : bState
'' Return T/F where T means the motor cog is running
    bState := (drv_state <> DCS_Unknown) ? true : false

PUB isStopped() : bState
'' Return T/F where T means the motor is stopped
    bState := (drv_state == DCS_STOPPED) ? true : false

PUB isStarting() : bState
'' Return T/F where T means the motor is spinning up
    bState := (drv_state == DCS_SPIN_UP) ? true : false

CON { --- PRIVATE TEST Methods --- }

  STABILIZE_LOOP_CT = 2000

VAR { test method data }
    long    bStartingUp
    long    runLoopCount
    long    startTicks
    long    faultHoldoffCtr
    long    currTarget
    long    minRange
    long    maxRange
    long    rangeStep
    long    prior_drv_state
    long    end_in_sec
    long    prior_MaxRpmIn10ths

PUB findFaultAtVoltage()
'' TEST ONLY: routine for locating motor speed limits
'' NOTE: invoke start() before invoking this method
    useDebug := false    ' NO debug in findFaultAtVoltage()
    debug("* ========  TEST Started!  =============================")

    ' find loop initial theory
    ' - find UPPER limit:
    '     search up from 60_000_000 to 400_000_000 (step 25_000_000)
    '          where max is motor fault or increment yields no change in RPM!
    ' - find LOWER limit:
    '     search down from 60_000_000 to 2_500_000 (step -2_500_000)
    '          where min no change in RPM or reached low end of range cps=8,rpm=5.3
    pinlow(TEST_ALL_PINS)
    setTargetAccel(0)   ' ensure starting at zero

    if drv_state == DCS_Unknown
        debug("* HOLD until Motor driver starts...")
        repeat until drv_state <> DCS_Unknown
        if drv_state <> DCS_Unknown
            debug("* Motor ready")
            repeat  ' lock here

    ' -----------------------------
    ' locate UPPER bound
    minRange := 60_000_000
    maxRange := 685_000_000
    rangeStep := 25_000_000

'{
    repeat
        debug(" ")
        debug("* --------------")
        debug("* RUN(UP-BND): ", udec(minRange), " --> ", udec(maxRange), udec(rangeStep))
        repeat currTarget from minRange to maxRange step rangeStep
            runAtSpeedToStopOrFault(currTarget)

            if fault
                ' exceeded limits, report  and quit
                'debug("- atFAULT:  ", udec_long(currTarget), udec_long(tvMaxRpmIn10ths), udec_long(tvMaxCntsInSec))
                clearFault(currTarget, rangeStep)
                waitms(500) ' delay for 1/2 sec (let motor settle)
                quit    ' done with loop, exit inner
            else
                ' good run check values done if only increasing current
                debug("- atEND:  ", udec_long(currTarget), udec_long(tvMaxRpmIn10ths), udec_long(tvMaxCntsInSec))

                if prior_MaxRpmIn10ths == tvMaxRpmIn10ths
                    ' have new power with same outcome end loop
                    debug("- end with more CURRENT, same value!")
                    quit    ' done with loop, exit inner

                waitms(500) ' delay for 1/2 sec (let motor settle)

            prior_MaxRpmIn10ths := tvMaxRpmIn10ths

        prior_MaxRpmIn10ths := 0
        minRange, maxRange, rangeStep := newUpperSearchRange(currTarget, minRange, maxRange, rangeStep)
        if rangeStep == 0
            debug("* RUN(UP-BND): Done...")
            quit    ' done with loop, exit outer

    'debug("-- HOLD --")
    'repeat

'}
    ' -----------------------------
    ' locate LOWER bound
    minRange := 2_000_000
    maxRange := 60_000_000
    rangeStep := -10_000_000
    prior_MaxRpmIn10ths := 0

    repeat
        debug(" ")
        debug("* --------------")
        debug("* RUN(LO-BND): ", sdec_long(minRange), " --> ", sdec_long(maxRange), sdec_long(rangeStep))
        repeat currTarget from maxRange to minRange step rangeStep
            tvMaxRpmIn10ths := tvMaxCntsInSec := 0  ' clear accum
            runAtSpeedToStopOrFault(currTarget)
            if fault
                ' exceeded limits, report  and quit
                'debug("- atFAULT:  ", udec_long(currTarget), udec_long(tvMaxRpmIn10ths), udec_long(tvMaxCntsInSec))
                clearFault(currTarget, rangeStep)
                quit
            else
                ' good run check values done if only increasing current
                debug("- atEND: ", sdec_long(currTarget), udec_long(tvMaxRpmIn10ths), udec_long(tvMaxCntsInSec))
                if (prior_MaxRpmIn10ths == tvMaxRpmIn10ths and tvMaxCntsInSec == 8)
                    ' have new power with same outcome end loop
                    debug("- end with same value, diff current!")
                    quit
            prior_MaxRpmIn10ths := tvMaxRpmIn10ths

        prior_MaxRpmIn10ths := 0
        minRange, maxRange, rangeStep := newLowerSearchRange(currTarget, minRange, maxRange, rangeStep)
        if rangeStep == 0
            debug("* RUN(DN-BND): Done...")
            quit    ' done with loop, exit outer

    debug("* RUN Complete!!")
    debug("* ======================================================")
    repeat  ' LOCK (stay) here!

PRI runAtSpeedToStopOrFault(nNewTarget) | endTimeInMS
' run motor to speed so we can check RPM and counts achieved
    'debug("* RUN-UP to ", sdec_long_(nNewTarget))
    prior_drv_state := DCS_Unknown
    bStartingUp := true
    end_in_sec := fault := faultHoldoffCtr := 0

    repeat
        pintoggle(TEST_PIN_OUTER_LOOP)  ' to HI

        endTimeInMS := getms() + 1000

        if bStartingUp == true and targetIncre == 0
            'debug("  ", udec(nNewTarget))
            setTargetAccel(nNewTarget)  ' request run at speed

            if pos == 0 and targetIncre <> 0
                'debug("* HOLD until Motor moves...")
                repeat until pos <> 0 or fault

                if pos == 0
                    debug("* Motor never moved")
                if fault
                    quit   ' FAULT and exit to next test

        if drv_state <> prior_drv_state and drv_state == DCS_AT_SPEED
            'debug("- at SPEED")
            bStartingUp := false

        if end_in_sec == 0 and drv_state == DCS_AT_SPEED
            'debug("- spindown in 5 sec")
            end_in_sec := getsec() + 5 ' spindown in 5 seconds

        if fault  ' if fault, end this pass
            quit   ' FAULT and exit to next test

        if targetIncre <> 0 and end_in_sec <> 0 and getsec() > end_in_sec
            'debug("-  stopping motor for this pass")
            setTargetAccel(0)    ' request stop

        elseif targetIncre == 0 and drv_state <> prior_drv_state and drv_state == DCS_STOPPED
            'debug("-LP- GOOD Run!")
            ' capture status from this test, and allow to loop to next run
            quit

        'debug("- set prior")
        prior_drv_state := drv_state

        'debug("- wait")
        pintoggle(TEST_PIN_OUTER_LOOP)  ' to LOW

        repeat until getms() > endTimeInMS   ' wait to create time base (1000 ok, 500 faults motor w/angle!!)

        if fault  ' if fault, end this pass
            quit   ' FAULT and exit to next test

    if fault == 0
        if drv_state <> DCS_STOPPED
            debug("-LP- ?? out of loop ?? --   WHY!!!")
    else
        debug("-LP- FAULT!")

PRI clearFault(tgt, stepCt)
    debug("- FAULT: ", sdec_long(tgt), sdec_long(stepCt))
    debug("-        ", udec_long(tvMaxRpmIn10ths), udec_long(tvMaxCntsInSec))
    setTargetAccel(0)
    fault := faultHoldoffCtr := 0
    tvMaxRpmIn10ths := tvMaxCntsInSec := tvMaxMmPerSec_x10 := 0

PRI newUpperSearchRange(target, nMinRange, nMaxRange, nRangeStep) : outMinRange, outMaxRange, outRangeStep
    ' locate UPPER bound
    '    minRange := 60_000_000
    '    maxRange := 685_000_000
    '    rangeStep := 25_000_000
    case nRangeStep
        25_000_000:
            outRangeStep := 5_000_000
        5_000_000:
            outRangeStep := 2_000_000
        other:
            ' do nothing, we don't go smaller
            outRangeStep := 0   ' force loop end

    outMinRange := target - nRangeStep
    outMaxRange := target - 1_000_000    ' apply correction so we don't test failing value again

PRI newLowerSearchRange(target, nMinRange, nMaxRange, nRangeStep) : outMinRange, outMaxRange, outRangeStep
    ' locate LOWER bound
    '    minRange := 5_000_000
    '    maxRange := 60_000_000
    '    rangeStep := -7_500_000
    case nRangeStep
        -10_000_000:
            outRangeStep := -5_000_000
        -5_000_000:
            outRangeStep := -2_000_000
        other:
            ' do nothing, we don't go smaller
            outRangeStep := 0   ' force loop end

    outMinRange := nMinRange
    outMaxRange := nMinRange + abs(nRangeStep)    ' apply correction so we don't test failing value again

CON { driver testing constants }

#0, MD_Unknown, MD_DONE, MD_START, MD_RUN_UP, MD_SLOW, MD_STOP, MD_SPEED_UP, MD_WAIT_AT_SPEED, MD_AT_SPEED_DONE, MD_WAIT_FOR_STOP, MD_STOPPED, MD_GAP_TWEEN_TESTS, MD_CHANGE_SPEED

#0, TS_Unknown, TS_DONE, TS_RAMP_FWD, TS_RAMP_REV, TS_SLOWDN_FWD, TS_SLOWDN_REV, TS_SPEEDUP_FWD, TS_SPEEDUP_REV, TS_CHG_FWD_REV, TS_CHG_REV_FWD

PUB TestExerciseMotorControl() | priorHall, eTestState, eTest, desiredAccel, desireAtSpeedSecs, endAtSecs
'' TEST ONLY: exercise all motor driver control forms (8 of them)
'' invoke start() before invoke of TestExerciseMotorControl()
    if useDebug
        debug(`logic l title 'Hall Effect' pos 25 440 'Hall' 3)

        debug(`term t title 'Status' pos 650 650 size 30 1 textsize 20 update)

        debug(`scope r title 'Duty and Error' pos 363 439 size 256 256 samples 256 rate 50)
        debug(`r 'Duty' 0 `(pwm_limit<<4) 256 0)
        debug(`r 'Error' -128 128 256 0 15)

        debug(`scope s title 'Voltages' pos 105 60 size 512 300 samples 256 rate 256)
        debug(`s 'U' 0 `(FRAME) 128 170)
        debug(`s 'V' 0 `(FRAME) 128 170)
        debug(`s 'W' 0 `(FRAME) 128 170)
        debug(`s 'Iu' 0 2000 128 70)
        debug(`s 'Iv' 0 2000 128 70)
        debug(`s 'Iw' 0 2000 128 70)
        debug(`s 'P' 0 100 128 10)

    pinlow(TEST_ALL_PINS)

    targetIncre := 0
    bStartingUp := true
    eTestState := MD_START
    eTest := TS_RAMP_FWD        ' first test to run
    desiredAccel := 0
    desireAtSpeedSecs := 0
    endAtSecs := 0

    repeat
        pintoggle(TEST_PIN_OUTER_LOOP)
        pintoggle(TEST_PIN_OUTER_LOOP)

        startTicks := getct()
        ' @18.5V 10_000_000 is 5.8 RPM
        ' @18.5V 10_000_000 is 5.8 RPM

        showStateNTest(eTest, eTestState)


        case eTest
            TS_RAMP_FWD:
                case eTestState
                    MD_START:
                        desiredAccel := -85_000_000  ' request run at + speed
                        desireAtSpeedSecs := 5
                        eTestState := MD_RUN_UP

                    MD_AT_SPEED_DONE:
                        eTestState := MD_STOP

                    MD_STOPPED:
                        eTest := TS_RAMP_REV
                        eTestState := MD_START
                        bStartingUp := true

                    other:
                        ' nothing more here
            TS_RAMP_REV:
                case eTestState
                    MD_START:
                        desiredAccel := 85_000_000  ' request run at + speed
                        desireAtSpeedSecs := 5
                        eTestState := MD_RUN_UP

                    MD_AT_SPEED_DONE:
                        eTestState := MD_STOP

                    MD_STOPPED:
                        eTest := TS_SLOWDN_FWD
                        eTestState := MD_START
                        bStartingUp := true

                    other:
                        ' nothing more here
            TS_SLOWDN_FWD:
                case eTestState
                    MD_START:
                        desiredAccel := 85_000_000  ' request run at + speed
                        desireAtSpeedSecs := 5
                        eTestState := MD_RUN_UP

                    MD_AT_SPEED_DONE:
                        if desiredAccel == 85_000_000
                            desiredAccel := 60_000_000  ' request run at + speed
                            eTestState := MD_CHANGE_SPEED
                        else
                            eTestState := MD_STOP

                    MD_STOPPED:
                        eTest := TS_SLOWDN_REV ' no more tests...
                        eTestState := MD_START
                        bStartingUp := true

                    other:
                        ' nothing more here
            TS_SLOWDN_REV:
                case eTestState
                    MD_START:
                        desiredAccel := -85_000_000  ' request run at + speed
                        desireAtSpeedSecs := 5
                        eTestState := MD_RUN_UP

                    MD_AT_SPEED_DONE:
                        if desiredAccel == -85_000_000
                            desiredAccel := -60_000_000  ' request run at + speed
                            eTestState := MD_CHANGE_SPEED
                        else
                            eTestState := MD_STOP

                    MD_STOPPED:
                        eTest := TS_SPEEDUP_FWD ' no more tests...
                        eTestState := MD_START
                        bStartingUp := true

                    other:
                        ' nothing more here
            TS_SPEEDUP_FWD:
                case eTestState
                    MD_START:
                        desiredAccel := 60_000_000  ' request run at + speed
                        desireAtSpeedSecs := 5
                        eTestState := MD_RUN_UP

                    MD_AT_SPEED_DONE:
                        if desiredAccel == 60_000_000
                            desiredAccel := 85_000_000  ' request run at + speed
                            eTestState := MD_CHANGE_SPEED
                        else
                            eTestState := MD_STOP

                    MD_STOPPED:
                        eTest := TS_SPEEDUP_REV ' no more tests...
                        eTestState := MD_START
                        bStartingUp := true

                    other:
                        ' nothing more here
            TS_SPEEDUP_REV:
                case eTestState
                    MD_START:
                        desiredAccel := -60_000_000  ' request run at + speed
                        desireAtSpeedSecs := 5
                        eTestState := MD_RUN_UP

                    MD_AT_SPEED_DONE:
                        if desiredAccel == -60_000_000
                            desiredAccel := -85_000_000  ' request run at + speed
                            eTestState := MD_CHANGE_SPEED
                        else
                            eTestState := MD_STOP

                    MD_STOPPED:
                        eTest := TS_CHG_FWD_REV ' no more tests...
                        eTestState := MD_START
                        bStartingUp := true

                    other:
                        ' nothing more here
            TS_CHG_FWD_REV:
                case eTestState
                    MD_START:
                        desiredAccel := 60_000_000  ' request run at + speed
                        desireAtSpeedSecs := 5
                        eTestState := MD_RUN_UP

                    MD_AT_SPEED_DONE:
                        if desiredAccel == 60_000_000
                            desiredAccel := -60_000_000  ' request run at + speed
                            eTestState := MD_CHANGE_SPEED
                        else
                            eTestState := MD_STOP

                    MD_STOPPED:
                        eTest := TS_CHG_REV_FWD ' no more tests...
                        eTestState := MD_START
                        bStartingUp := true

                    other:
                        ' nothing more here
            TS_CHG_REV_FWD:
                case eTestState
                    MD_START:
                        desiredAccel := -60_000_000  ' request run at + speed
                        desireAtSpeedSecs := 5
                        eTestState := MD_RUN_UP

                    MD_AT_SPEED_DONE:
                        if desiredAccel == -60_000_000
                            desiredAccel := 60_000_000  ' request run at + speed
                            eTestState := MD_CHANGE_SPEED
                        else
                            eTestState := MD_STOP

                    MD_STOPPED:
                        eTest := TS_DONE ' no more tests...
                        eTestState := MD_START
                        bStartingUp := true

                    other:
                        ' nothing more here
            other:  ' nothing more here

        showStateNTest(eTest, eTestState)

        if eTest == TS_DONE
            quit    ' all tests complete, exit loop

        case eTestState
            MD_RUN_UP:
                if bStartingUp and targetIncre == 0
                    setTargetAccel(desiredAccel)  ' request run at speed
                    eTestState := MD_WAIT_AT_SPEED
                    debug("* coast")

            MD_CHANGE_SPEED:
                if targetIncre <> 0
                    setTargetAccel(desiredAccel)  ' request run at speed
                    endAtSecs := getsec() + desireAtSpeedSecs
                    eTestState := MD_WAIT_AT_SPEED

            MD_WAIT_AT_SPEED:
                if bStartingUp and drv_state == DCS_AT_SPEED
                    debug("* starting up == false")
                    endAtSecs := getsec() + desireAtSpeedSecs
                    bStartingUp := false
                if drv_state == DCS_AT_SPEED and getsec() > endAtSecs
                    debug("* coast time Expired")
                    eTestState := MD_AT_SPEED_DONE

            MD_STOP:
                setTargetAccel(0)  ' request stop
                eTestState := MD_WAIT_FOR_STOP
                debug("* stopping")

            MD_WAIT_FOR_STOP:
                if targetIncre == 0 and drv_state == DCS_STOPPED
                    debug("* STOPPED")
                    endAtSecs := getsec() + desireAtSpeedSecs
                    eTestState := MD_GAP_TWEEN_TESTS

            MD_GAP_TWEEN_TESTS:
                if drv_state == DCS_STOPPED and getsec() > endAtSecs
                    debug("* idle time Expired")
                    eTestState := MD_STOPPED

            other:
                ' nothing to do here

        showStateNTest(eTest, eTestState)

        if hall <> priorHall                    'if hall effect changed, update logic display
            priorHall := hall
            if useDebug
                debug(`l `ubin_byte_(hall))

        if useDebug
            debug(`t 0 '`sdec(duty, pos)' update)       'update terminal and scope displays
            debug(`r `sdec_(duty, err))
            debug(`s `sdec_long_array_(@drive_u,3) `sdec_long_array_(@sense_u,4))

        maxDrvTics := loop_ticks > maxDrvTics ? loop_ticks : maxDrvTics
        minDrvTics := loop_ticks > 10 && loop_ticks < minDrvTics  ? loop_ticks : minDrvTics

        if fault and faultHoldoffCtr > STABILIZE_LOOP_CT
            debug("** FAULT **")
            quit

        if faultHoldoffCtr++ < STABILIZE_LOOP_CT            ' if still getting sense of motor hold-off faults
            fault~
        if fault and faultHoldoffCtr > STABILIZE_LOOP_CT and 0   ' if fault, shut down
            if useDebug
                debug(`t 0 'FAULT' update)
            stop()
            repeat    ' and lock here!

        'waitus(1000)
        waitct(startTicks + ticks1ms)    ' wait to create time base (1000 ok, 500 faults motor w/angle!!)

    debug("** Run Complete")
    repeat   ' HOLD here forever

DAT { interp strings }

    pUnkMsg         byte    "?unk?",0
    pMDDone         byte    "MD_DONE",0
    pMDStart        byte    "MD_START",0
    pMDRunUp        byte    "MD_RUN_UP",0
    pMDSlow         byte    "MD_SLOW",0
    pMDStop         byte    "MD_STOP",0
    pMDSpeedUp      byte    "MD_SPEED_UP",0
    pMDWaitAtSpeed  byte    "MD_WT_AT_SPEED",0
    pMDWaitForStop  byte   "MD_WT_FOR_STOP",0
    pMDAtSpeedDone  byte    "MD_AT_SPEED_DONE",0
    pMDStopped      byte    "MD_STOPPED",0
    pMDGapTween     byte    "MD_GAP_TWEEN_TESTS",0
    pMDChgSpeed     byte    "MD_CHANGE_SPEED",0

    pBadCode        byte    "?BAD-CODE?",0

    pTSRampFwd      byte    "TS_RAMP_FWD",0
    pTSRampRev      byte    "TS_RAMP_REV",0
    pTSSlowDnFwd    byte    "TS_SLOWDN_FWD",0
    pTSSlowDnRev    byte    "TS_SLOWDN_REV",0
    pTSSpeedUpFwd   byte    "TS_SPEEDUP_FWD",0
    pTSSpeedUpRev   byte    "TS_SPEEDUP_REV",0
    pTSChgFwdRev    byte    "TS_CHG_FWD_REV",0
    pTSChgRevFwd    byte    "TS_CHG_REV_FWD",0
    pTSDone         byte    "TS_DONE",0

    priorState      long     MD_Unknown
    priorTest       long    TS_Unknown

PRI showStateNTest(enumTest, enumTestState) | pTestStr, pStateStr
    pStateStr := @pBadCode
    case enumTestState
        MD_DONE:
            pStateStr := @pMDDone
        MD_START:
            pStateStr := @pMDStart
        MD_RUN_UP:
             pStateStr := @pMDRunUp
        MD_SLOW:
            pStateStr := @pMDSlow
        MD_STOP:
            pStateStr := @pMDStop
        MD_SPEED_UP:
            pStateStr := @pMDSpeedUp
        MD_WAIT_AT_SPEED:
            pStateStr := @pMDWaitAtSpeed
        MD_AT_SPEED_DONE:
            pStateStr := @pMDAtSpeedDone
        MD_WAIT_FOR_STOP:
            pStateStr := @pMDWaitForStop
        MD_STOPPED:
            pStateStr := @pMDStopped
        MD_GAP_TWEEN_TESTS:
            pStateStr := @pMDGapTween
        MD_CHANGE_SPEED:
            pStateStr := @pMDChgSpeed
        other:
            pStateStr := @pUnkMsg

    pTestStr := @pBadCode
    case enumTest
        TS_Unknown:
            pTestStr := @pUnkMsg
        TS_RAMP_FWD:
            pTestStr := @pTSRampFwd
        TS_RAMP_REV:
            pTestStr := @pTSRampRev
        TS_SLOWDN_FWD:
            pTestStr := @pTSSlowDnFwd
        TS_SLOWDN_REV:
            pTestStr := @pTSSlowDnRev
        TS_SPEEDUP_FWD:
            pTestStr := @pTSSpeedUpFwd
        TS_SPEEDUP_REV:
            pTestStr := @pTSSpeedUpRev
        TS_CHG_FWD_REV:
            pTestStr := @pTSChgFwdRev
        TS_CHG_REV_FWD:
            pTestStr := @pTSChgRevFwd
        other:
            pTestStr := @pUnkMsg
    if priorState <> enumTestState or priorTest <> enumTest
        debug("--> TST:[", zstr_(pTestStr), "], ST:[", zstr_(pStateStr), "] <--")
        priorState := enumTestState
        priorTest := enumTest

PUB testMotorNoFault() | priorHall, increment, decrement
'' TEST ONLY: run motor at medium speed without reacting to "fault" we do this
''  so we can probe the motor board
'' invoke start() before invoke of testMotorNoFault()
    useDebug := true    ' force use of debug in testMotorNoFault()

    if useDebug
        debug(`logic l title 'Hall Effect' pos 25 440 'Hall' 3)

        debug(`term t title 'Status' pos 650 650 size 30 1 textsize 20 update)

        debug(`scope r title 'Duty and Error' pos 363 439 size 256 256 samples 256 rate 50)
        debug(`r 'Duty' 0 `(pwm_limit<<4) 256 0)
        debug(`r 'Error' -128 128 256 0 15)

        debug(`scope s title 'Voltages' pos 105 60 size 512 300 samples 256 rate 256)
        debug(`s 'U' 0 `(FRAME) 128 170)
        debug(`s 'V' 0 `(FRAME) 128 170)
        debug(`s 'W' 0 `(FRAME) 128 170)
        debug(`s 'Iu' 0 2000 128 70)
        debug(`s 'Iv' 0 2000 128 70)
        debug(`s 'Iw' 0 2000 128 70)
        debug(`s 'P' 0 100 128 10)

    pinlow(TEST_ALL_PINS)

    bStartingUp := true

    runLoopCount := 30_000 ' count of 1 ms loops (20 seconds)
    'runLoopCount := 30_000 ' count of 1 ms loops (30 seconds)
    'runLoopCount := 40_000 ' count of 1 ms loops (40 seconds)

    repeat
        pintoggle(TEST_PIN_OUTER_LOOP)
        pintoggle(TEST_PIN_OUTER_LOOP)

        startTicks := getct()
        ' @18.5V 10_000_000 is 5.8 RPM
        ' @18.5V 10_000_000 is 5.8 RPM

        if bStartingUp and targetIncre == 0
            setTargetAccel(10_000_000)  ' request run at slow speed continually

        if drv_state == DCS_AT_SPEED
            bStartingUp := false
{
        if runLoopCount > 0 && bStartingUp == false
            runLoopCount--
            if runLoopCount == 0
                setTargetAccel(0)    ' request stop
'}
        if hall <> priorHall                    'if hall effect changed, update logic display
            priorHall := hall
            if useDebug
                debug(`l `ubin_byte_(hall))

        if useDebug
            debug(`t 0 '`sdec(duty, pos)' update)       'update terminal and scope displays
            debug(`r `sdec_(duty, err))
            debug(`s `sdec_long_array_(@drive_u,3) `sdec_long_array_(@sense_u,4))

        maxDrvTics := loop_ticks > maxDrvTics ? loop_ticks : maxDrvTics
        minDrvTics := loop_ticks > 10 && loop_ticks < minDrvTics  ? loop_ticks : minDrvTics

{
        if faultHoldoffCtr++ < STABILIZE_LOOP_CT            ' if still getting sense of motor hold-off faults
            fault~
        if fault and faultHoldoffCtr > STABILIZE_LOOP_CT and 0   ' if fault, shut down
            if useDebug
                debug(`t 0 'FAULT' update)
            stop()
            repeat    ' and lock here!
'}

        'waitus(1000)
        waitct(startTicks + ticks1ms)    ' wait to create time base (1000 ok, 500 faults motor w/angle!!)

CON { --- PRIVATE Utility Methods --- }

PUB validBasePinForChoice(userBasePin) : legalBasePin
'' VALIDATE users' base-pin choice returns legalBasePin or INVALID_PIN_BASE
    legalBasePin := userBasePin
    CASE userBasePin
        PINS_P0_P15 :
        PINS_P16_P31 :
        PINS_P32_P47 :
        OTHER :
            legalBasePin := INVALID_PIN_BASE

PUB validVoltageForChoice(userVoltage) : legalVoltage
'' VALIDATE users' voltage choice returns legalVoltage or INVALID_VOLTAGE
    legalVoltage := userVoltage
    CASE userVoltage
        PWR_6V:
        PWR_7p4V:
        PWR_11p1V:
        PWR_12V:
        PWR_14p8V:
        PWR_18p5V:
        PWR_22p2V:
        PWR_24V:
        OTHER:
            legalVoltage := INVALID_VOLTAGE
    debug("*VAL* ", sdec_long(legalVoltage))

PRI map(inValue, inMin, inMax, outMin, outMax) : nResult | slope
' Maps inValue in range inMin..inMax to new value in range outMin..outMax
    nResult := 0
    if inValue <> 0
        if (inValue > 0)
            ' treat positive values out-of-bounds
            if (inValue <= inMin)
                nResult := outMin
            elseif (inValue >= inMax)
                nResult :=  outMax
        elseif (inValue < 0)
            ' treat negative values out-of-bounds
            if (inValue >= inMin)
                nResult := outMin
            elseif (inValue <= inMax)
                nResult :=  outMax
        ' NOT  out-of-bounds, so scale the inValue
        if nResult == 0
            slope := (outMax - outMin) / (inMax - inMin)
            nResult := outMin + slope * (inValue - inMin)
    'debug("- map() ", sdec_long(inValue - inMin), sdec_long(inMin) , sdec_long(inMax), sdec_long(inMax - inMin))
    'debug("-       ", sdec_long(slope), sdec_long(outMin) , sdec_long(outMax), sdec_long(outMax - outMin))
    debug("- map() ", sdec_long(inValue) , " --> ", sdec_long(nResult))

PRI incrementForPower(nUserPower) : nMotorIncre
' translate -100 to +100 value to Incre value needed by motor
    if userSelectedVolts == VALUE_NOT_SET
        abort

    if nUserPower < 0
        ' map REV request
        nMotorIncre := map(nUserPower, -1, -100, minRevIncreAtPwr, maxRevIncreAtPwr)
    elseif nUserPower > 0
        ' map FWD request
        nMotorIncre := map(nUserPower, +1, +100, minFwdIncreAtPwr, maxFwdIncreAtPwr)
    else
        ' this is a STOP request
        nMotorIncre := 0    ' stop!

PRI confgurePowerLimits(userVoltage) | selectedPower
' set up our motor drive limits based upon the user configured Voltage selection
    selectedPower := validVoltageForChoice(userVoltage)
    debug("* ENTRY CFG ", sdec_long(selectedPower))
    if selectedPower == INVALID_VOLTAGE
        abort

    userSelectedVolts := VALUE_NOT_SET  ' preset
    minFwdIncreAtPwr := VALUE_NOT_SET
    maxFwdIncreAtPwr := VALUE_NOT_SET
    minRevIncreAtPwr := VALUE_NOT_SET
    maxRevIncreAtPwr := VALUE_NOT_SET

    CASE selectedPower
        PWR_6V:
        PWR_7p4V:
        PWR_11p1V:
            maxFwdIncreAtPwr := 90_000_000      ' anything above yields RPM 165.3, cts/Sec 248 (until fault at 170.6 256)
            maxRevIncreAtPwr := -90_000_000     ' anything above yields RPM 165.3, cts/Sec 248 (until fault at 170.6 256)
        PWR_12V:
            maxFwdIncreAtPwr := 97_000_000      ' anything above yields RPM 181.3, cts/Sec 272 (until fault at 186.6 280)
            maxRevIncreAtPwr := -97_000_000     ' anything above yields RPM 181.3, cts/Sec 272 (until fault at 186.6 280)
        PWR_14p8V:
            maxFwdIncreAtPwr := 120_000_000     ' anything above yields RPM 224.0, cts/Sec 336 (until fault at 229.8 344)
            maxRevIncreAtPwr := -120_000_000    ' anything above yields RPM 224.0, cts/Sec 336 (until fault at 229.8 344)
        PWR_18p5V:
            maxFwdIncreAtPwr := 147_000_000     ' anything above yields RPM 272.0, cts/Sec 408 (until fault at 277.3 416)
            maxRevIncreAtPwr := -147_000_000    ' anything above yields RPM 272.0, cts/Sec 408 (until fault at 277.3 416)
        PWR_22p2V:
            maxFwdIncreAtPwr := 172_000_000     ' anything above yields RPM 320.0, cts/Sec 480 (until fault at 325.3 480)
            maxRevIncreAtPwr := -172_000_000    ' anything above yields RPM 320.0, cts/Sec 480 (until fault at 325.3 480)
        PWR_24V:
       other:
            debug("*???* Unknown: ", sdec_long(selectedPower))
            abort   ' SHOULD NEVER get here!

    if maxFwdIncreAtPwr <> VALUE_NOT_SET
        userSelectedVolts := selectedPower
        minFwdIncreAtPwr := 5_000_000           ' anything below yields RPM 5.3, cts/Sec 8
        minRevIncreAtPwr := 0 - minFwdIncreAtPwr
    debug("* EXIT 2 CFG ", sdec_long(userSelectedVolts))

PRI setTargetAccel(nTgtIncr)
    targetIncre := nTgtIncr
    debug("-MOT- ", sdec_long(targetIncre))
    tvTargetIncreInM := nTgtIncr / 10_000

CON { --- HDMI Debug Support --- }

CON { Constants for HDMI Debug }

    DBG_GROUPS_CT = 3
    DBG_MAX_VARS_IN_GROUP = 7

VAR { Data Structure for HDMI Debug }

    long    pTitlesAr[DBG_GROUPS_CT + 1]    ' first value is max vars
    long    pVarCtAr[DBG_GROUPS_CT]
    long    pNamesAr[DBG_GROUPS_CT*DBG_MAX_VARS_IN_GROUP]
    long    pValsAr[DBG_GROUPS_CT*DBG_MAX_VARS_IN_GROUP]

DAT { Literals for HDMI Debug }
' motor drive data
    nameTitle1  byte    "Motor Drive",0
    name10      byte    "hall",0
    name11      byte    "pos",0
    name12      byte    "duty",0
    name13      byte    "err",0
    name14      byte    "loopTicks",0
    name15      byte    "state",0
    name16      byte    "FAULT",0
    nextAddr1
    dataLen1     long    @nextAddr1 - @nameTitle1

' motor sense data
    nameTitle2  byte    "Motor Sense",0
    name20      byte    "RPM 10ths",0
    name21      byte    "RPM",0
    name22      byte    "cnts/sec",0
    name23      byte    "delta",0
    nextAddr2
    dataLen2     long    @nextAddr2 - @nameTitle2

' motor rate  data
    nameTitle3  byte    "Motor Rate(.1)",0
    name30      byte    "RPM",0
    name31      byte    "cnts/sec",0
    name32      byte    "f/s",0
    name33      byte    "MPH",0
    name34      byte    "kM/H",0
    name35      byte    "mm/s",0
    name36      byte    "Angl/10k",0
    nextAddr3
    dataLen3     long    @nextAddr3 - @nameTitle3

PRI loadDisplayList() | nGrpOffset, nValsGrpOffset, nVarsInGroup
' do internal one-time setup of driver debug data
    nGrpOffset := 0
    nVarsInGroup := 7
    LONG[@pTitlesAr][nGrpOffset] := @nameTitle1
    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup
    ' populate the empty name/value ptr tables
    nValsGrpOffset := nGrpOffset * DBG_MAX_VARS_IN_GROUP
    LONG[@pNamesAr][nValsGrpOffset + 0] := @name10
    LONG[@pNamesAr][nValsGrpOffset + 1] := @name11
    LONG[@pNamesAr][nValsGrpOffset + 2] := @name12
    LONG[@pNamesAr][nValsGrpOffset + 3] := @name13
    LONG[@pNamesAr][nValsGrpOffset + 4] := @name14
    LONG[@pNamesAr][nValsGrpOffset + 5] := @name15
    LONG[@pNamesAr][nValsGrpOffset + 6] := @name16
    LONG[@pValsAr][nValsGrpOffset + 0] := @hall
    LONG[@pValsAr][nValsGrpOffset + 1] := @pos
    LONG[@pValsAr][nValsGrpOffset + 2] := @duty
    LONG[@pValsAr][nValsGrpOffset + 3] := @err
    LONG[@pValsAr][nValsGrpOffset + 4] := @loop_ticks
    LONG[@pValsAr][nValsGrpOffset + 5] := @drv_state
    LONG[@pValsAr][nValsGrpOffset + 6] := @fault

    nGrpOffset := 1
    nVarsInGroup := 4
    LONG[@pTitlesAr][nGrpOffset] := @nameTitle2
    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup
     ' populate the empty name/value ptr tables
    nValsGrpOffset := nGrpOffset * DBG_MAX_VARS_IN_GROUP ' mult by vars in prior group
    LONG[@pNamesAr][nValsGrpOffset + 0] := @name20
    LONG[@pNamesAr][nValsGrpOffset + 1] := @name21
    LONG[@pNamesAr][nValsGrpOffset + 2] := @name22
    LONG[@pNamesAr][nValsGrpOffset + 3] := @name23
    LONG[@pValsAr][nValsGrpOffset + 0] := @tvRpm_x10
    LONG[@pValsAr][nValsGrpOffset + 1] := @rpm
    LONG[@pValsAr][nValsGrpOffset + 2] := @cntsInSec
    LONG[@pValsAr][nValsGrpOffset + 3] := @deltaTicks

    nGrpOffset := 2
    nVarsInGroup := 7
    LONG[@pTitlesAr][nGrpOffset] := @nameTitle3
    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup
     ' populate the empty name/value ptr tables
    nValsGrpOffset := nGrpOffset * DBG_MAX_VARS_IN_GROUP ' mult by vars in prior group
    LONG[@pNamesAr][nValsGrpOffset + 0] := @name30
    LONG[@pNamesAr][nValsGrpOffset + 1] := @name31
    LONG[@pNamesAr][nValsGrpOffset + 2] := @name32
    LONG[@pNamesAr][nValsGrpOffset + 3] := @name33
    LONG[@pNamesAr][nValsGrpOffset + 4] := @name34
    LONG[@pNamesAr][nValsGrpOffset + 5] := @name35
    LONG[@pNamesAr][nValsGrpOffset + 6] := @name36
    LONG[@pValsAr][nValsGrpOffset + 0] := @tvMaxRpmIn10ths
    LONG[@pValsAr][nValsGrpOffset + 1] := @tvMaxCntsInSec
    LONG[@pValsAr][nValsGrpOffset + 2] := @tvMaxFps_x10
    LONG[@pValsAr][nValsGrpOffset + 3] := @tvMaxMPH_x10
    LONG[@pValsAr][nValsGrpOffset + 4] := @tvMaxkPH_x10
    LONG[@pValsAr][nValsGrpOffset + 5] := @tvMaxMmPerSec_x10
    LONG[@pValsAr][nValsGrpOffset + 6] := @tvTargetIncreInM

    ' tell our table size to reader
    nGrpOffset := 3
    LONG[@pTitlesAr][nGrpOffset] := DBG_MAX_VARS_IN_GROUP

PUB getDebugData() : nGroups, pGroupTitles, pGroupNames, pGroupVarCts, pGroupVars | tmpAbsPtr
'' Return pointers to HDMI-debug data structures for this motor-object instance
    loadDisplayList()
    nGroups := DBG_GROUPS_CT
    pGroupTitles := @pTitlesAr         ' pStr = long[pTitlesAr][grpIdx]
    pGroupVarCts := @pVarCtAr          ' nNbrGrpVars = long[pVarCtAr][grpIdx]
    pGroupNames := @pNamesAr           ' pGrpNameAr = long[pNamesAr][grpIdx], pVarName = long[pNameAr][varIdx]  where varIdx is from 0 to nNbrGrpVars - 1
    pGroupVars := @pValsAr             ' pGrpLongVar = long[pValsAr][grpIdx][varIdx]  where varIdx is from 0 to nNbrGrpVars - 1
    if showHDMIDebug
        debug("* -------------")
        debug("* MOTR DAT values: ", uhex_long(@hall), uhex_long_array(@hall, 4))
        debug("* MOTR VAR values: ", uhex_long(@tvRpm_x10), uhex_long_array(@tvRpm_x10, 4))
        debug("* NAMEs SOURCE1: ", uhex_long(@nameTitle1), uhex_byte_array(@nameTitle1, dataLen1))
        debug("* NAMEs SOURCE2: ", uhex_long(@nameTitle2), uhex_byte_array(@nameTitle2, dataLen2))
        debug("* NAMEs SOURCE3: ", uhex_long(@nameTitle3), uhex_byte_array(@nameTitle3, dataLen3))
        debug("* -------------")
        debug("* MOTR DL title: ", uhex_long(@pTitlesAr), uhex_long_array(@pTitlesAr, DBG_GROUPS_CT + 1))
        debug("* MOTR DL VarCt: ", uhex_long(@pVarCtAr), uhex_long_array(@pVarCtAr, DBG_GROUPS_CT))
        debug("* MOTR DL Names: ", uhex_long(@pNamesAr), uhex_long_array(@pNamesAr, DBG_GROUPS_CT * DBG_MAX_VARS_IN_GROUP))
        debug("* MOTR DL Values: ", uhex_long(@pValsAr), uhex_long_array(@pValsAr, DBG_GROUPS_CT * DBG_MAX_VARS_IN_GROUP))
        debug("* -------------")
        debug("* MOTR PARM values: ", uhex_long(@nGroups), uhex_long_array(@nGroups, 5))
        debug("* -------------")
        debug("* MOTR Sent: ", udec(nGroups), uhex_long(pGroupTitles), uhex_long(pGroupNames), uhex_long(pGroupVarCts), uhex_long(pGroupVars))
        debug("* =============")


CON { -- TASK position tracking -- }

  STACK_SIZE_LONGS = 48
  WINDOW_SIZE = 5

VAR { arrays }
    long    countsWindow[WINDOW_SIZE]
    long    taskStack[STACK_SIZE_LONGS]

PRI taskPostionSense() | senseStartTicks, posThis8th, fValue, fFps, timeNow
' TASK: every 1/8 Sec (8Hz) read motor pos and calculate RPM and countOf90ths/Sec

    'longfill(@countsWindow, 0, WINDOW_SIZE) ' zero our window accum
    'tvMaxRpmIn10ths := tvMaxCntsInSec := tvMaxMmPerSec_x10 := 0
    'tvMaxFps_x10 := tvMaxMPH_x10 := tvMaxkPH_x10 := 0
    tvMaxRpmIn10ths := tvMaxCntsInSec := tvMaxMmPerSec_x10 := 0

    repeat
        ' if just starting up (or MOTOR FAULT), reset our tracker
        if drv_state == DCS_FAULTED or senseStartTicks == 0
            longfill(@countsWindow, 0, WINDOW_SIZE) ' zero our window accum
            tvMaxFps_x10 := tvMaxMPH_x10 := tvMaxkPH_x10 := 0
            winEntryCt := windowSum := winIndex := 0
            posTrkHallTicks := 0

        senseStartTicks := getct()
        pintoggle(TEST_PIN_SENSE_LOOP)
        pintoggle(TEST_PIN_SENSE_LOOP)

        newCntsInSec := distanceIn90ths(pos)            ' Read the next sensor value
        windowSum -= LONG[@countsWindow][winIndex]          ' Remove the oldest entry from the sum
        long [@countsWindow][winIndex] := newCntsInSec      ' place the newest reading into the window
        windowSum += newCntsInSec                           ' Add the newest reading to the sum
        winIndex := (winIndex + 1) +// WINDOW_SIZE          ' Increment the index, and wrap to 0 if it exceeds the window size
        if winEntryCt < WINDOW_SIZE                         ' incr number of samples in sum until is window size
            winEntryCt++

        cntsInSec := (windowSum / winEntryCt) * 8                 ' moving average, scaled
        tvRpm_x10 := (cntsInSec * 60) / 9
        rpm := tvRpm_x10 / 10
        rpmTenths := tvRpm_x10 +// 10

        tvMaxRpmIn10ths := MAX(tvRpm_x10, tvMaxRpmIn10ths)
        tvMaxCntsInSec := MAX(cntsInSec, tvMaxCntsInSec)

        posThis8th := windowSum / winEntryCt
        posTrkHallTicks += posThis8th
        ' pos is in hall-steps of 4Degr each.
        ' circumference of wheel is in mm x10
        '   degrees of rotation is cntsInSec * 4
        '   number of rotations is degrees / 360
        '   dist in mm is (circInMM_x10 * rotations) / 10
        mmPerSec_x10 := (((cntsInSec * 4) * circInMM_x10) / 360)
        ftPerSec_x10 := distConv.mmps2fps(mmPerSec_x10 * 10)
        kmh_x10 := distConv.mmps2kmh(mmPerSec_x10 * 10)
        mph_x10 := distConv.fps2mph(ftPerSec_x10)

        tvMaxMmPerSec_x10 := MAX(mmPerSec_x10, tvMaxMmPerSec_x10)
        tvMaxFps_x10 := MAX(ftPerSec_x10, tvMaxFps_x10)
        tvMaxMPH_x10 := MAX(mph_x10, tvMaxMPH_x10)
        tvMaxkPH_x10 := MAX(kmh_x10, tvMaxkPH_x10)

        ' if user set time/distance to stop then stop if we are past the time or distance
        if motorStopMSecs > 0
            timeNow := getms()
            if timeNow > motorStopMSecs
                setTargetAccel(0)
                motorStopMSecs := 0 ' and clear user request
        elseif motorStopHallTicks > 0
            if posTrkHallTicks > motorStopHallTicks
                setTargetAccel(0)
                motorStopHallTicks := 0 ' and clear user request

        deltaTicks := getct() - senseStartTicks

        ' code uses about 1_880 ticks. This is little over 9 uS  @200MHz clock
        '   wait remainder of 125 mSec before next sample
        waitct(senseStartTicks + ticks125ms)    ' wait to create "sense" time-base

PRI MAX(a,b) : nMax
' return max of a or b
    nMax := (a > b) ? a : b

PRI distanceIn90ths(newPos) : n90ths
    if newPos == priorPos
        n90ths := 0
    elseif newPos < 0
        ' handle pos negative case
        if priorPos < 0
            '  -7 -> -9 = abs(-9) - abs(-7) = abs(2) = 2
            '  -11 -> -9 = abs(-9) - abs(-11) = abs(-2) = 2
            n90ths := abs(abs(newPos) - abs(priorPos))
        else
            '  9 -> -9 = 18 = abs(9) + abs(-9) = 18
            n90ths := abs(newPos) + abs(priorPos)
    else
        ' handle pos positive case
        if priorPos < 0
            ' -9 -> 6 = 6 + abs(-9) = 15
            ' -3 -> 6 = 6 + abs(-3) = 9
            n90ths := newPos + abs(priorPos)
        else
            ' 9 -> 6 = 6 - 9 = abs(-3) = 3
            ' 9 -> 12 = 12 - 9 = abs(3) = 3
            n90ths := abs(newPos - priorPos)
    priorPos := newPos

CON { --- The Motor driver --- }

CON { driver interface Constants}

    '  DCS_STOPPED          - motor is stopped
    '  DCS_SPIN_UP          - motor is ramping up to speed, then will be at AT_SPEED
    '  DCS_AT_SPEED         - motor is holding at speed
    '  DCS_SPIN_DN          - motor is stopping, then will be at STOPPED
    '  DCS_SLOWING_DN       - motor is slowing down (just a speed change), then will be at AT_SPEED
    '  DCS_SLOW_TO_CHG      - motor is slowing down to change direction, then will be SPEEDING_UP
    '
    #0, DCS_Unknown, DCS_STOPPED, DCS_SPIN_UP, DCS_AT_SPEED, DCS_SPIN_DN, DCS_SLOWING_DN, DCS_SLOW_TO_CHG, DCS_FAULTED


CON { driver internal Constants}

    FRAME    = 1024 * 6 / 2       '6 ADC samples make 1 PWM frame, divide by two for triangle PWM
'    OFFSET   = 40                ' enforced dead time in clock cycles (at 200_000_000 -> 200 nSec)
'    OFFSET   = 80                ' enforced dead time in clock cycles (at 200_000_000 -> 400 nSec)
'    OFFSET   = 108                ' enforced dead time in clock cycles (at 270_000_000 -> 400 nSec)
'    PWMLIM   = FRAME - OFFSET     'PWM duty hard limit 1/2 freq of PWM

VAR { Data Structure for PASM Driver }
  ' remember these are zeroed at run time
    long    motorCog                            ' record ID of cog we start (0 = not started)
    long    senseCog                            ' record ID of cog we start (0 = not started)

    long    maxDrvTics                          ' accumulators for study of driver
    long    minDrvTics

    long    pinbase                             ' 1 long                must set initially
    long    params_ptr                          ' 1 long                must set initially
    ' / ----------------------------
    long    targetIncre                         ' 1 long                must set to cause motion
    ' 14 longs come from driver, the 14th, fault also from driver but only when happens
    long    drive_u, drive_v, drive_w           ' 3 sequential longs    returns data continually
    long    sense_u, sense_v, sense_w, sense_i  ' 4 sequential longs    returns data continually
    '  ----- HDMI monitored! ----
    long    hall, pos, duty, err                ' 4 sequential longs    returns data continually
    long    loop_ticks                          ' 1 sequential long     returns control loop duration in ticks continually
    long    loop_ctcks                          ' 1 sequential long     returns drive loop duration in ticks continually
    long    drv_state                           ' enum [DCS_STOPPED, DCS_SPIN_UP, DCS_AT_SPEED, DCS_SPIN_DN]
    ' \ ----------------------------
    long    fault                               ' 1 sequential long     written to 1 on fault

VAR { Data for Motor Position Tracking }

    long    winIndex
    long    winEntryCt
    long    newCntsInSec
    long    windowSum
    '  ----- HDMI monitored! ----
    long    tvRpm_x10
    long    rpm
    long    cntsInSec
    long    deltaTicks
    long    tvMaxRpmIn10ths
    long    tvMaxFps_x10
    long    tvMaxMPH_x10
    long    tvMaxkPH_x10
    long    tvMaxMmPerSec_x10
    long    tvMaxCntsInSec
    long    tvTargetIncreInM
    '  --------------------------
    long    priorPos
    long    rpmTenths
    long    mmPerSec_x10
    long    ftPerSec_x10
    long    kmh_x10
    long    mph_x10
    '  --------------------------
    long    posTrkHallTicks
    long    circInMM_x10
    long    tickInMM_x10

DAT  {  DRIVER w/Motor Parameters  }
'

    ' ------ HDMI monitored! -----
    ' (driver reads this into own memory each iteration)
    params                                  ' motor-control parameters, reloaded every frame
    offset_fwd  long    20 frac 360         ' 96 frac 360 (Doug's motor)
    offset_rev  long    340 frac 360        ' 228 frac 360 (Doug's motor)
    duty_min    long    0                   ' was 100 << 4 #> OFFSET << 4 but now runtime loaded
    duty_max    long    0                   ' was PWMLIM << 4 <# PWMLIM << 4 but now runtime loaded
    duty_up     long    16
    duty_dn     long    4
    dead_gap    long    0           ' this was OFFSET but now runtime loaded
    pwm_limit   long    0           ' this was PWMLIM but now runtime loaded
    ctrl_ticks  long    0           ' # clock ticks needed to create 2 kHz motor control loop
    stop_mode   long    SM_FLOAT    ' enum: [SM_FLOAT, SM_BRAKE]
    ramp_up     long    25_000      ' 12_500-18.5V 25k angle increment: add this every 500 uSec to ramp up to speed
    ramp_dn     long    25_000      ' 25k angle decrement: subtract this every 500 uSec to ramp down to 0
    ' ------ --------------- -----

'
' PASM Driver Program
'
                org

driver          rdlong  x, ptra++                   ' get base pin
                rdlong  params_ptr_, ptra++         ' get parameters pointer
                add     ptra, #1*4                  ' point to return data, angle is at long index [-1]

                mov     drv_state_, #DCS_STOPPED    ' motor is currently stopped

                or      all_pins, x                 ' finish the all-pins variable
                add     drive_pins, x               ' finish the drive-pins variable

                drvl    drvrLoopPnFld               ' preset test pins to low
                drvl    drvrTmrPnFld

                mov     y, #0                       ' make single-pin variables
.pin            altd    y, #pin_adc_u_i
                mov     0-0, x
                add     x, #1
                incmod  y, #15      wc
    if_nc       jmp     #.pin

                dirl    all_pins                    ' disable PWM and ADC pins for configuration

                wrpin   adc_modes+0, pin_adc_u_i        ' set up ADC pins
                wrpin   adc_modes+0, pin_adc_v_i
                wrpin   adc_modes+0, pin_adc_w_i
                wrpin   adc_modes+0, pin_adc_cur_i

                wxpin   #10, pin_adc_u_i                ' (#10 = 1024-clock / 11-bit conversion)
                wxpin   #10, pin_adc_v_i
                wxpin   #10, pin_adc_w_i
                wxpin   #10, pin_adc_cur_i

                wrpin   pwmn, pin_pwm_u_l               ' set up PWM pins
                wrpin   pwmt, pin_pwm_u_h
                wrpin   pwmn, pin_pwm_v_l
                wrpin   pwmt, pin_pwm_v_h
                wrpin   pwmn, pin_pwm_w_l
                wrpin   pwmt, pin_pwm_w_h

                wxpin   fram, pin_pwm_u_l
                wxpin   fram, pin_pwm_u_h
                wxpin   fram, pin_pwm_v_l
                wxpin   fram, pin_pwm_v_h
                wxpin   fram, pin_pwm_w_l
                wxpin   fram, pin_pwm_w_h

                dirh    all_pins                        ' enable ADC and PWM pins simultaneously for phase-locked operation

                dirl    pin_hall_u                          ' remake HALL pins inputs (they were in-between ADC and PWM pins)
                dirl    pin_hall_v
                dirl    pin_hall_w

                mov     duty_, #0                       ' reset duty
                mov     pos_, #0                        ' reset pos
                mov     loop_dtcks_, #0                 ' just in case
                mov     loop_ctcks_, #0                 ' just in case
                mov     drv_incr, #0                    ' reset incr to stopped
                mov     prior_incr, #0                  ' just in case
                mov     fwdrev, #0                      ' just in case

                ' preset our starting angle
                'call    #.initAngleFmHall   ' NOTE: may not need this a SPIN_UP does this

                ' reset timer (schedule next control time)
                getct   ctrlEndTix                      ' get now
                addct1  ctrlEndTix, cfg_ctcks_          '   add in next time we need to run
                ' start driver
                jmp     #.run1stTime
    ' -------------------------------------------------------------------------


.loop           jnct1   #.noAdjust
    ' =========================================================================
    '  MOTOR DRIVE LOOP - runs at 2.0 kHz (500.0 uSec period)
    '       time to adjust angle...
    ' -------------------------------------------------------------------------
.run1stTime
                getct   ctrlSrtTix                      ' remember when we started this loop
                outnot  drvrTmrPnFld                    ' toggle TEST marker pin
                outnot  drvrTmrPnFld

                ' let's see if user wants to change speed
                ' have new drive command?
                rdlong  tgt_incr, ptra[-1]              ' get rate of increment ( +/- drive power, or 0 stop)
                cmp     prior_incr, tgt_incr        wz  ' Q: do we have a new request?
    if_z        jmp     #.currRqst      ' nope, just continue what we are doing

    ' ====================================
.newRqst    ' have new request
            ' determine what we need to do
    ' ====================================
                ' if NEW request is stop
                cmp     tgt_incr, stop_requst       wz  ' Q: is stop request?
    if_z        mov     prior_incr, tgt_incr            ' have new request - set this a latest prior!
    if_z        mov     drv_state_, #DCS_SPIN_DN        ' yes, so start ramp down
    if_z        jmp     #.rampDn
                ' have start or speed adjustment
                cmp     drv_state_, #DCS_FAULTED    wz  ' Q: is MOTOR faulted?
    if_nz       jmp     #.chkStopped
            ' MOTOR faulted, clear fault so we can run again
                mov     tgt_incr, #0                    ' reset incr to stopped
                mov     drv_incr, #0                    ' reset incr to stopped
                mov     prior_incr, #0                  ' along with prior
                mov     fwdrev, #0                      ' just in case
                mov     duty_, #0                       ' just in case
                mov     drv_state_, #DCS_STOPPED        ' reset fault to stopped
                call    #.initAngleFmHall               ' figure out where motor is once again
                dirh    drive_pins                      ' set control pins back to output
                ' fall thru to next handling code
.chkStopped
                cmp     drv_state_, #DCS_STOPPED    wz  ' Q: is start request?
    if_nz       jmp     #.notStart
                mov     prior_incr, tgt_incr            ' have new request - set this a latest prior!
                mov     drv_state_, #DCS_SPIN_UP        ' yes, we are going to ramp up
                ' if we have floated all drive pins, re-enable them
                cmp     stop_mode_, #SM_FLOAT       wz  ' Q: did we float pins at last stop?
    if_z        dirh    drive_pins                      ' yes, set control pins back to output
                jmp     #.rampUp            ' now go ramp up!

.notStart
    ' ------------------------------------
               ' no, We have a speed adjustment (determine how to do...)
                '  NOTEs: [ + >> +, + >> -, - >> -, - >> +]
                '    + to - -> make direction change (slow down, ramp up in other direction)
                '    - to + -> make direction change (slow down, ramp up  in other direction)
                '    + to larger + -> ramp up to new
                '    + to smaller + -> ramp down to new
                '    - to larger - -> ramp up to new
                '    - to smaller - -> ramp down to new

                ' first do we have same sign?
                testb   prior_incr, #31             wc  ' find dual '-' signs (CY=both neg)
                testb   tgt_incr, #31               andc
    if_c        jmp     #.endSame
                testbn  prior_incr, #31             wc  ' find dual '+' signs (CY=both pos)
                testbn  tgt_incr, #31               andc
.endSame
    if_nc       jmp     #.notSame
.haveSame   ' we have prior and new with same sign, so should we slow down or speed up?
                ' let's change speed
                testb   tgt_incr, #31               wc
    if_c        jmp     #.doSloNeg
.doSloPos
                cmps    prior_incr, tgt_incr        wcz ' Q: Should we slow dn or speed up? (CY=speed up)
                mov     prior_incr, tgt_incr            ' have new request - set this a latest prior!
    if_c        mov     drv_state_, #DCS_SPIN_UP        ' CY=1: speed up
    if_c        jmp     #.rampUp
    if_nc       mov     drv_state_, #DCS_SLOWING_DN     ' CY=0: slow down
    if_nc       jmp     #.slowDn
.doSloNeg
                cmps    prior_incr, tgt_incr        wcz ' Q: Should we slow dn or speed up? (CY=speed up)
                mov     prior_incr, tgt_incr            ' have new request - set this a latest prior!
    if_nc       mov     drv_state_, #DCS_SPIN_UP        ' CY=1: speed up
    if_nc       jmp     #.rampUp
    if_c        mov     drv_state_, #DCS_SLOWING_DN     ' CY=0: slow down
    if_c        jmp     #.slowDn
    ' ------------------------------------
.notSame    ' we have prior and new but NOT the same sign, let's slowdown then change direction
                ' let's change direction
                mov     prior_incr, tgt_incr            ' have new request - set this a latest prior!
                mov     drv_state_, #DCS_SLOW_TO_CHG
                jmp     #.slow2Chg


    ' ====================================
.currRqst   ' No new request, continue with
            '  current request
    ' ====================================
.chkStop        cmp     drv_state_, #DCS_STOPPED    wz
    if_z        jmp     #.endRqst                       ' motor STOPPED, just exit (w/o increment)
                ' motor is running, if ramp do ramp, else increment
.chkUp          cmp     drv_state_, #DCS_SPIN_UP    wz
    if_nz       jmp     #.chkDn                         ' not this, go check next
.rampUp
                ' if we don't have it, preset our starting angle (assume motor moved during float!)
                cmp     stop_mode_, #SM_FLOAT       wz  ' if we are "floating" pins at stop
    if_z        or      drv_incr, drv_incr          wz  ' -and- we are stopped, just about to spin up
    if_z        call    #.initAngleFmHall               ' then, let's first get motor initial angle for smooth startup
                ' do next UP adjustment or set at-speed
                testb   tgt_incr, #31               wc  ' Q: moving FWD or REV? (CY=REV)
    if_c        jmp     #.haveRUpRev
                adds    drv_incr, ramp_up_              ' FWD: increase increment (speeding up)
                cmps    tgt_incr, drv_incr          wc  ' Q: Did we exceed target?
                jmp     #.lastRUpZero
.haveRUpRev
    if_c        subs    drv_incr, ramp_up_              ' REV: decrease increment (speeding up)
                cmps    drv_incr, tgt_incr          wc  ' Q: Did we exceed target?
.lastRUpZero
    if_c        mov     drv_incr, tgt_incr              ' yes, reset to target!
                cmps    tgt_incr, drv_incr          wz  ' Q: Are we at target? (compare again to handle both cases)
    if_z        mov     drv_state_, #DCS_AT_SPEED       ' yes, show we got here!
                jmp     #.justIncr      ' go increment motor angle, then exit

    ' ------------------------------------
.chkDn          cmp     drv_state_, #DCS_SPIN_DN    wz
    if_nz       jmp     #.chkSlow2Chg
.rampDn
                ' do next DOWN adjustment or set stopped
                '  (increment > 0, we are not stopped)
                ' NOTE!!! tgt_incr is likely ZERO so we don't test its sign bit here
                '  instead we test the sign bit of the current driver target as we are spinning down
                '  from the current driver target to ZERO!
                testb   drv_incr, #31               wc  ' Q: moving FWD or REV? (CY=REV)
    if_c        jmp     #.haveRDnRev
                subs    drv_incr, ramp_dn_              ' FWD: decrease increment (slowing down)
                cmps    drv_incr, #0                wcz
    if_nc_and_nz jmp    #.justIncr                       ' just increment motor angle, then exit
                jmp     #.lastRDnzero
.haveRDnRev
                adds    drv_incr, ramp_dn_              ' REV: increase increment, toward zero (slowing down)
                cmps    drv_incr, #0                wcz
    if_c        jmp    #.justIncr                       ' just increment motor angle, then exit
.lastRDnzero
                subs    drv_incr, drv_incr              ' set to zero
                mov     drv_state_, #DCS_STOPPED        ' report that we are stopped
                mov     err_, #0                        ' reset err
                mov     duty_, #0                       ' reset duty
                ' if we are to freewheel the motor let's float all drive pins
                cmp     stop_mode_, #SM_FLOAT       wz
    if_z        dirl    drive_pins                      ' float all control pins (make them inputs)
                jmp     #.endRqst       ' motor STOPPED, just exit (w/o increment)

     ' ------------------------------------
.chkSlow2Chg    cmp     drv_state_, #DCS_SLOW_TO_CHG wz
    if_nz       jmp     #.chkSlowDn                     ' not this, go check next
.slow2Chg
                ' do next DOWN adjustment, if stopped do spinup
                '  (increment > 0, we are not stopped)
                ' NOTE!!! tgt_incr is where we are going after we spin down so we don't test its sign bit here
                '  instead we test the sign bit of the current driver target as we are spinning down
                '  from the current driver target to ZERO!
                testb   drv_incr, #31               wc  ' Q: moving FWD or REV? (CY=REV)
    if_c        jmp     #.haveS2CRev
                subs    drv_incr, ramp_dn_              ' FWD: decrease increment (slowing down)
                cmps    drv_incr, #0                wcz
    if_nc_and_nz jmp    #.justIncr                      ' just increment motor angle, then exit
                jmp     #.lastS2CZero
.haveS2CRev
                adds    drv_incr, ramp_dn_              ' REV: increase increment, toward zero (slowing down)
                cmps    drv_incr, #0                wcz
    if_c        jmp    #.justIncr                       ' just increment motor angle, then exit
.lastS2CZero
                subs    drv_incr, drv_incr              ' set to zero
                sub     drv_incr, drv_incr              ' set to zero
                mov     drv_state_, #DCS_SPIN_UP        ' report that we are stopped
                jmp     #.rampUp        ' go immediately start moving in opposite direction

    ' ------------------------------------
.chkSlowDn      cmp     drv_state_, #DCS_SLOWING_DN wz
    if_nz       jmp     #.justIncr          ' not this, guess we just increment motor angle, then exit
.slowDn
                ' do next DOWN adjustment or set at speed
                '  (increment > 0, we are not stopped)
                testb   tgt_incr, #31               wc  ' Q: moving FWD or REV? (CY=REV)
    if_c        jmp     #.haveSDnRev
                subs    drv_incr, ramp_dn_              ' FWD: increase increment (speeding up)
                cmps    tgt_incr, drv_incr          wc  ' Q: Did we exceed target?
                jmp     #.lastSDnZero
.haveSDnRev
    if_c        adds    drv_incr, ramp_dn_              ' REV: decrease increment (speeding up)
                cmps    drv_incr, tgt_incr          wc  ' Q: Did we exceed target?
.lastSDnZero
    if_c        mov     drv_incr, tgt_incr              ' yes, reset to target!
                cmps    tgt_incr, drv_incr          wz  ' Q: Are we at target? (compare again to handle both cases)
    if_z        mov     drv_state_, #DCS_AT_SPEED       ' yes, show we got here!
                'jmp     #.justIncr      ' go increment motor angle, then exit

    ' ------------------------------------
.justIncr   ' just do our increment of angle and we're done!
                add     angle, drv_incr
                'jmp    #.endRqst      ' done, fall thru
.endRqst
                getct   loop_ctcks_                 ' how long was this pass? send to host
                sub     loop_ctcks_, ctrlSrtTix
                ' reset timer (schedule next control loop run)
                mov     ctrlEndTix, ctrlSrtTix
                addct1  ctrlEndTix, cfg_ctcks_
                'jmp    #.noAdjust      ' done, fall thru
    ' -------------------------------------------------------------------------


.noAdjust
    ' =========================================================================
    '  MOTOR Speed Maintenance Loop - runs at 43.9 kHz (22.8 uSec period)
    '       keep our error rate low...
    ' -------------------------------------------------------------------------
                getct   drvrSrtTix                  ' remember when we started this loop
                outnot  drvrLoopPnFld               ' toggle TEST marker pin
                outnot  drvrLoopPnFld
                call    #.wait4adc                  ' allow ADC rest period (Period 1 of 6)

                rdpin   vio_levels+0, pin_adc_u_i       ' VIO samples done, read them
                rdpin   vio_levels+1, pin_adc_v_i
                rdpin   vio_levels+2, pin_adc_w_i
                rdpin   vio_levels+3, pin_adc_cur_i

                wrpin   adc_modes+2, pin_adc_u_i        ' switch ADC to pin
                wrpin   adc_modes+2, pin_adc_v_i
                wrpin   adc_modes+2, pin_adc_w_i
                wrpin   adc_modes+2, pin_adc_cur_i

                call    #.wait4adc                  ' allow ADC rest period (Period 2 of 6)
                call    #.wait4adc                  ' allow ADC rest period (Period 3 of 6)

                rdpin   sense_u_, pin_adc_u_i           ' pin samples done, read them
                rdpin   sense_v_, pin_adc_v_i
                rdpin   sense_w_, pin_adc_w_i
                rdpin   sense_i_, pin_adc_cur_i

                wrpin   adc_modes+0, pin_adc_u_i        ' switch ADC to GIO calibration
                wrpin   adc_modes+0, pin_adc_v_i
                wrpin   adc_modes+0, pin_adc_w_i
                wrpin   adc_modes+0, pin_adc_cur_i

                call    #.wait4adc                  ' allow ADC rest period (Period 4 of 6)

                sub     vio_levels+0, gio_levels+0  ' compute (3300 << 11) / (vio_level - gio_level)
                sub     vio_levels+1, gio_levels+1
                sub     vio_levels+2, gio_levels+2
                sub     vio_levels+3, gio_levels+3

                qdiv    numerator, vio_levels+0
                qdiv    numerator, vio_levels+1
                qdiv    numerator, vio_levels+2
                qdiv    numerator, vio_levels+3

                getqx   scl_levels+0
                waitx   #4
                getqx   scl_levels+1
                waitx   #4
                getqx   scl_levels+2
                waitx   #4
                getqx   scl_levels+3

                sub     sense_u_, gio_levels+0      ' compute (quotient * (pin_level - gio_level)) >> 11
                muls    sense_u_, scl_levels+0
                sar     sense_u_, #11

                sub     sense_v_, gio_levels+1
                muls    sense_v_, scl_levels+1
                sar     sense_v_, #11

                sub     sense_w_, gio_levels+2
                muls    sense_w_, scl_levels+2
                sar     sense_w_, #11

                sub     sense_i_, gio_levels+3
                muls    sense_i_, scl_levels+3
                sar     sense_i_, #11

                call    #.wait4adc                  ' allow ADC rest period (Period 5 of 6)

                rdpin   gio_levels+0, pin_adc_u_i       ' GIO samples done, read them
                rdpin   gio_levels+1, pin_adc_v_i
                rdpin   gio_levels+2, pin_adc_w_i
                rdpin   gio_levels+3, pin_adc_cur_i

                wrpin   adc_modes+1, pin_adc_u_i        ' switch ADC to VIO calibration
                wrpin   adc_modes+1, pin_adc_v_i
                wrpin   adc_modes+1, pin_adc_w_i
                wrpin   adc_modes+1, pin_adc_cur_i

                call    #.wait4adc                  ' allow ADC rest period (Period 6 of 6)

                mov     y, duty_                    ' feed three CORDIC operations to get phase drive levels
                shr     y, #4
                mov     x, angle
                qrotate y, x
                add     x, third
                qrotate y, x
                add     x, third
                qrotate y, x

                getqy   drive_u_                    ' get three CORDIC results
                getqy   drive_v_
                getqy   drive_w_

                mov     x, drive_u_                 ' get smallest drive level into x
                cmps    x, drive_v_         wc
    if_nc       mov     x, drive_v_
                cmps    x, drive_w_         wc
    if_nc       mov     x, drive_w_

                mov     y, drive_u_                 ' get largest drive level into y
                cmps    y, drive_v_         wc
    if_c        mov     y, drive_v_
                cmps    y, drive_w_         wc
    if_c        mov     y, drive_w_

                add     x, y                        ' sum smallest and largest, then divide by 2
                sar     x, #1

                sub     drive_u_, x                 ' subtract difference from drive levels
                sub     drive_v_, x
                sub     drive_w_, x

                add     drive_u_, bias              ' add center-bias and dead-time offsets to update PWMs
                add     drive_u_, dead_gap_
                wypin   drive_u_, pin_pwm_u_l
                sub     drive_u_, dead_gap_
                wypin   drive_u_, pin_pwm_u_h

                add     drive_v_, bias
                add     drive_v_, dead_gap_
                wypin   drive_v_, pin_pwm_v_l
                sub     drive_v_, dead_gap_
                wypin   drive_v_, pin_pwm_v_h

                add     drive_w_, bias
                add     drive_w_, dead_gap_
                wypin   drive_w_, pin_pwm_w_l
                sub     drive_w_, dead_gap_
                wypin   drive_w_, pin_pwm_w_h

                testp   pin_hall_w              wc      ' read hall effect sensor
                rcl     hall_, #1
                testp   pin_hall_v              wc
                rcl     hall_, #1
                testp   pin_hall_u              wc
                rcl     hall_, #1
                and     hall_, #%111_111            ' (old << 3 | new) [ooo:nnn]
                altgb   hall_, #deltas              ' load byte deltas[hall_] -> [-1, 0, 1]
                getbyte x
                signx   x, #7                       ' sign-extend bit7
                add     pos_, x                     ' add to current pos_

                setq    #12-1                       ' load fresh parameter table (12 longs)
                rdlong  params_ptr_+1, params_ptr_

                cmpm    angle, prior_angle  wcz     ' if angle has changed, forward or reverse?
    if_nz       wrc     fwdrev
                mov     prior_angle, angle

                testb   fwdrev, #0          wc      ' determine error
                bitc    hall_, #3
                and     hall_, #%1111
                alts    hall_, #hall_angles
                mov     err_, 0-0
    if_c        add     err_, offset_fwd_
    if_nc       add     err_, offset_rev_
                subr    err_, angle
                sar     err_, #24
                bitl    hall_, #3

                abs     x, err_                     ' fault?
                cmp     x, #125             wc
    if_nc       dirl    drive_pins                  ' at FAULT: float all control pins (make them inputs)
    if_nc       mov     drv_state_,#DCS_FAULTED     '  also on FAULT: mark our motor as FAULTED
    if_nc       wrlong  #1, ptra[14]                '  also on FAULT: report fault
                sub     x, #256/6           wc      ' modulate duty
    if_nc       muls    x, duty_up_
    if_c        muls    x, duty_dn_
                sar     x, #8
                add     duty_, x
                fles    duty_, duty_max_            ' keep duty within limits
                fges    duty_, duty_min_

                getct   loop_dtcks_                 ' how long was this iteration? send to host
                sub     loop_dtcks_, drvrSrtTix

                setq    #14-1                       ' write drive[3]/sense[4]/hall/pos/duty/err/ticks[2]/state to hub
                wrlong  drive_u_, ptra

                jmp     #.loop                      ' main loop

    ' =========================================================================
    '  PRIVATE (Utiility) Subroutines
    ' -------------------------------------------------------------------------
.wait4adc       testp   pin_adc_u_i             wc      ' wait for next ADC sample (6 samples = PWM frame)
    if_nc       jmp     #.wait4adc

    _ret_       akpin   pin_adc_u_i

.initAngleFmHall
                ' init angle & prior from current motor position
                testp   pin_hall_w              wc      ' read hall effect sensor
                rcl     hall_, #1
                testp   pin_hall_v              wc
                rcl     hall_, #1
                testp   pin_hall_u              wc
                rcl     hall_, #1
                and     hall_, #%111                ' assume forward
                alts    hall_, #hall_angles
                mov     angle, 0-0
                add     angle, offset_fwd_          ' adjust phase offset for hall sensor
    _ret_       mov     prior_angle, angle          ' show we are already here

    '
    ' =========================================================================

all_pins	long	15 << 6			            ' all-pins variable (addpins 15) needs OR of basepin
drive_pins	long	(7 << 6) + 8	            ' drive-pins variable (+8 addpins 7) needs ADD of basepin
pwmt        long    %000_000000_01_01000_0  ' PWM true
pwmn        long    %001_000000_01_01000_0  ' PWM not
fram        long    FRAME << 16 + 1         ' PWM frame setting
bias        long    FRAME / 2               ' PWM center-frame bias
third       long    1 FRAC 3                ' 120 degrees
numerator   long    3300 << 11              ' numerator for ADC calculations
stop_requst long    0                       ' 32-bits of zero
ramp_up_dly long    8                       ' cycles 8,7,6... -> 0 then back to 8, over and over

drvrLoopPnFld   long    TEST_PIN_DRIVER_LOOP addpins 0  ' convert to pinfield
drvrTmrPnFld    long    TEST_PIN_DRIVER_TMR addpins 0  ' convert to pinfield

adc_modes   long    p_adc_gio | p_adc       ' adc modes, by state
            long    p_adc_vio | p_adc
            long    p_adc_1x  | p_adc

deltas      byte    0, 0, 0, 0, 0, 0, 0, 0  ' Hall-effect-sensor position deltas from (old<<3 | new)
            byte    0, 0, 0,-1, 0, 1, 0, 0
            byte    0, 0, 0, 1, 0, 0,-1, 0
            byte    0, 1,-1, 0, 0, 0, 0, 0
            byte    0, 0, 0, 0, 0,-1, 1, 0
            byte    0,-1, 0, 0, 1, 0, 0, 0
            byte    0, 0, 1, 0,-1, 0, 0, 0
            byte    0, 0, 0, 0, 0, 0, 0, 0

hall_angles long    0           ' forward-direction table
            long    0 frac 6    '%001
            long    4 frac 6    '%010
            long    5 frac 6    '%011
            long    2 frac 6    '%100
            long    1 frac 6    '%101
            long    3 frac 6    '%110
            long    0
            long    0           ' reverse-direction table
            long    5 frac 6    '%001
            long    3 frac 6    '%010
            long    4 frac 6    '%011
            long    1 frac 6    '%100
            long    0 frac 6    '%101
            long    2 frac 6    '%110
            long    0


x           res     1           ' miscellaneous
y           res     1

' measurements
drvrSrtTix  res 1
drvrEndTix  res 1
ctrlSrtTix  res 1
ctrlEndTix  res 1

' driver inputs
tgt_incr    res 1       ' current user requested target increment
prior_incr  res 1       ' prior user requested target increment
' control loop variables
drv_incr    res 1       ' current driver increment
angle       res 1       ' current driver angle
prior_angle res 1       ' prior driver angle
fwdrev      res 1       ' driver current direction used for indexing into hall angle table

' PIN names
pin_adc_u_i     res 1       ' single-pin variables
pin_adc_v_i     res 1
pin_adc_w_i     res 1
pin_adc_x_i     res 1
pin_adc_cur_i   res 1
pin_hall_u      res 1
pin_hall_v      res 1
pin_hall_w      res 1
pin_pwm_u_l     res 1
pin_pwm_u_h     res 1
pin_pwm_v_l     res 1
pin_pwm_v_h     res 1
pin_pwm_w_l     res 1
pin_pwm_w_h     res 1
pin_pwm_x_l     res 1
pin_pwm_x_h     res 1

'  ADC variables
gio_levels      res 4
vio_levels      res 4
scl_levels      res 4

' ------------------------------
'  PRECISE FORMAT:
'   copied in-to driver each loop iteration
params_ptr_ res 1               ' params_ptr must be followed by the 12 parameters
offset_fwd_ res 1
offset_rev_ res 1
duty_min_   res 1
duty_max_   res 1
duty_up_    res 1
duty_dn_    res 1
dead_gap_   res 1               ' this was OFFSET but now passed into driver
pwm_limit_  res 1               ' this was PWMLIM but now passed into driver
cfg_ctcks_  res 1
stop_mode_  res 1
ramp_up_    res 1               ' angle increment: add this every 500 uSec to ramp up to speed
ramp_dn_    res 1               ' angle decrement: subtract this every 500 uSec to ramp down to 0

' ------------------------------
'  PRECISE FORMAT:
'   copied out-of driver each loop iteration
drive_u_    res 1               '   14 contiguous longs for return data structure
drive_v_    res 1
drive_w_    res 1
sense_u_    res 1
sense_v_    res 1
sense_w_    res 1
sense_i_    res 1
hall_       res 1
pos_        res 1
duty_       res 1
err_        res 1
loop_dtcks_ res 1
loop_ctcks_ res 1
drv_state_  res 1       ' enum: DCS_STOPPED, DCS_SPIN_UP, DCS_AT_SPEED, DCS_SPIN_DN, etc
' fault is here... (but external only)


CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2022 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
