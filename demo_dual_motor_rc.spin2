'' =================================================================================================
''
''   File....... demo_dual_motor_rc.spin2
''   Purpose.... Demonstrate driving a two-wheeled platform
''   Authors.... Stephen M Moraco
''               -- Copyright (c) 2022 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Mar 2022
''   Updated.... 19 Mar 2022
''
'' =================================================================================================

CON { timing }

  CLK_FREQ = 270_000_000                                        ' system freq as a constant
  _clkfreq = CLK_FREQ                                           ' set system clock

CON { fixed io pins }

  RX1      = 63  { I }                                          ' programming / debug
  TX1      = 62  { O }

  SF_CS    = 61  { O }                                          ' serial flash
  SF_SCK   = 60  { O }
  SF_SDO   = 59  { O }
  SF_SDI   = 58  { I }

  LA_CHAN0 = 56  { O }
  LA_CHAN1 = 57  { O }

  SBUS_RX  = 58  { I }



OBJ { our Drive Subsystem }

    user        : "isp_bldc_motor_userconfig"       ' driver configuration
    wheels      : "isp_steering"                    ' the dual-drive BLDC motors
    remoteCtl   : "isp_flysky_rx"                   ' the FlySky Transmitter

VAR

    long    remoteCog


PUB main() | statusOK
'' DEMO Driving a two wheeled platform

    debug("* demo dual motor control via R/C")

    ' start our motor drivers (left and right)
    wheels.start(wheels.PINS_P0_P15, wheels.PINS_P16_P31, wheels.PWR_12V)

    ' just don't draw current at stop
    wheels.holdAtStop(false)

    ' ---- TEST TEST TEST ----
    'remoteCtl.manualCalibrate()
    'debug("-- HOLD --")
    'repeat  ' hold here for now
    ' ---- TEST TEST TEST ----

    debug("* Set up - remote control")

    remoteCog := remoteCtl.start(SBUS_RX)
    statusOK := remoteCog <> 0 ? TRUE : FALSE
    if statusOK
        'remoteCtl.manualCalibrate()
        debug("R/C Running...")
        remoteControlMotor()
    else
        debug("EEEE: SBUS rcvr not started?!")

{
    debug("* HOLD here - not starting motors...")
    repeat
'}
{
    ' now drive!
    waitUntilMotorReady()

    debug("* BOTH Wheels")
    wheels.driveDirection(50, -25)
    wheels.stopAfterTime(15, wheels.DTU_SEC)      ' hold at speed for 15 Sec

    waitUntilMotorDone()

    wheels.driveDirection(50, 25)
    wheels.stopAfterTime(15, wheels.DTU_SEC)      ' hold at speed for 15 Sec

    waitUntilMotorDone()
'}
{
    debug("* LT Wheel")
    wheels.driveAtPower(50, 0)
    wheels.stopAfterTime(15, wheels.DTU_SEC)      ' hold at speed for 15 Sec

    waitUntilMotorDone()

    debug("* RT Wheel")
    wheels.driveAtPower(0, 50)
    wheels.stopAfterTime(15, wheels.DTU_SEC)      ' hold at speed for 15 Sec

    waitUntilMotorDone()
'}

    ' turn off our SBUS drivers
    remoteCtl.stop()
    ' turn off our motor drivers
    wheels.stop()

    debug("* DONE")

PRI waitUntilMotorReady()
    if wheels.isReady() == false
        debug("* wait motors ready...")
        repeat
            if wheels.isReady()
                quit
            else
                waitms(2)
    debug("* Motors ready, let's drive!")


PRI waitUntilMotorDone()
    if wheels.isStarting() == false
         debug("* wait until motors start...")
         repeat
            if wheels.isStarting()
                quit
            else
                waitms(2)

    if wheels.isStopped() == false
        debug("* wait until motors finish...")
        repeat
            if wheels.isStopped()
                quit
            else
                waitms(2)
    debug("* Motors stopped!")

CON

   VALUE_NOT_SET = -2

VAR

    long    priorSpeed
    long    priorDirection
    long    rcSpeed
    long    rcDirection

PUB remoteControlMotor() | bLastIgnoreJoyStks, bIgnoreJoySticks, bDoneTesting, bLastShowState, bShowState, loopCt, bShowDebugStatus

    waitms(3000)    ' wait for 3 sec for backend to catch up

    'arm.gripClosed()
    debug("------------")
    debug("- Lt Joy Hz - direction")
    debug("- Rt Joy Vt - speed")
    debug("------------")
    debug("* swA DN    - enable joystick servo control")
    'debug("* swB Toggle - ---")
    'debug("* swC UP - ---")
    'debug("* swC MID - ---")
    'debug("* swC DN - ---")
    debug("* swD DN - end control")
    debug("------------")

    bLastShowState := VALUE_NOT_SET ' value can't happen
    bLastIgnoreJoyStks := VALUE_NOT_SET ' value can't happen

    loopCt := 0
    repeat

        bShowDebugStatus := loopCt < 2 ? TRUE : FALSE
        remoteCtl.showDebug(bShowDebugStatus)

        ' SwA Ignore JoySticks
        bIgnoreJoySticks := remoteCtl.swIsOn(remoteCtl.CTL_SW_A)
        'bShowState := remoteCtl.swIsOn(remoteCtl.CTL_SW_B)
        'eJawStateSW := remoteCtl.readSwitch(remoteCtl.CTL_SW_C)
        ' SwD done, end loop!
        bDoneTesting := remoteCtl.swIsOff(remoteCtl.CTL_SW_D)

        if bLastShowState == VALUE_NOT_SET
            bLastShowState := bShowState

        if bLastIgnoreJoyStks == VALUE_NOT_SET
            bLastIgnoreJoyStks := bIgnoreJoySticks

        if bShowState <> bLastShowState
            'showServoPositions()
            bLastShowState := bShowState

{
        if eJawStateSW <> eLastJawState
            debug("-- JAW change --")
            case eJawStateSW
                remoteCtl.SST_OFF:
                    debug("  Jaw Open")
                    arm.gripOpen()
                remoteCtl.SST_MID:
                    debug("  Jaw Mid-Open")
                    arm.gripMidOpen()
                remoteCtl.SST_ON:
                    arm.gripClosed()
                    debug("  Jaw Close")
                other:
                    term.fstr1(string("** ERROR  swC value=%d UNKNOWN"), eJawStateSW)
            eLastJawState := eJawStateSW
'}

        if bLastIgnoreJoyStks <> bIgnoreJoySticks
            if bIgnoreJoySticks
                debug("  Motor CTL OFF")
            else
                debug("  Motor CTL enabled")
            bLastIgnoreJoyStks := bIgnoreJoySticks

        if not bIgnoreJoySticks
            rcSpeed, rcDirection := updPosnBothJoy(1)
            if priorDirection <> rcDirection or priorSpeed <> rcSpeed
                debug("- JOY ", sdec_long(rcSpeed), sdec_long(rcDirection))
                wheels.driveDirection(rcSpeed, rcDirection)
                priorDirection := rcDirection
                priorSpeed := rcSpeed

        if bDoneTesting
            debug("--> quit loop")
            quit

        waitms(500) ' wait 1/4 second, before next loop
        loopCt++

    ' done, stop our motors
    wheels.stop()

{
PRI showServoPositions()
    debug("--- SERVOS ---")
    ' add code here
    arm.showservoPositions()
    debug("--------------")
'}

PRI updPosnBothJoy(nLoopCount): speed, direction | rawSpeed, rawDirection, rngMin, rngMax
    ' loop on joysitck values forwarding them to our servos
    if nLoopCount < 1
        nLoopCount := 1
    repeat nLoopCount
        ' swD which servo pair?

        ' route Rt Joystick Vt (spring center) to FWD/REV (speed)
        rawSpeed := remoteCtl.readChannel(remoteCtl.CTL_RT_JOY_VT)
        rngMin, rngMax := remoteCtl.chanMinMax(remoteCtl.CTL_RT_JOY_VT)
        speed := map(rawSpeed, rngMin, rngMax, -100, +100)

{
        ' route Rt Joystick Hz (spring center) to direction
        posn := remoteCtl.readChannel(remoteCtl.CTL_RT_JOY_HZ)
        rngMin, rngMax := remoteCtl.chanMinMax(remoteCtl.CTL_RT_JOY_HZ)
        arm.positionServo(arm.SERVO_WRIST_FLEX, posn, rngMin, rngMax)
'}

        ' route Lt Joystick Hz (spring center) to direction
        rawDirection := remoteCtl.readChannel(remoteCtl.CTL_LT_JOY_HZ)
        rngMin, rngMax := remoteCtl.chanMinMax(remoteCtl.CTL_LT_JOY_HZ)
        direction := map(rawDirection, rngMin, rngMax, -100, +100)

{
        ' route Lt Joystick Vt to Elbow
        posn := remoteCtl.readChannel(remoteCtl.CTL_LT_JOY_VT)
        rngMin, rngMax := remoteCtl.chanMinMax(remoteCtl.CTL_LT_JOY_VT)
        arm.positionServo(arm.SERVO_ELBOW, posn, rngMin, rngMax)
'}

PRI map(inValue,  inMin,  inMax,  outMin,  outMax) : outValue
{
    REF: https://www.arduino.cc/reference/en/language/functions/math/map

    Re-maps a number from one range to another. That is, a value of fromLow would get mapped to toLow,
    a value of fromHigh to toHigh, values in-between to values in-between, etc.

    Does not constrain values to within the range, because out-of-range values are sometimes intended and
    useful. The constrain() function may be used either before or after this function, if limits to the ranges are desired.

    Note that the "lower bounds" of either range may be larger or smaller than the "upper bounds" so the
    map() function may be used to reverse a range of numbers, for example

    y = map(x, 1, 50, 50, 1);

    The function also handles negative numbers well, so that this example

    y = map(x, 1, 50, 50, -100);

    is also valid and works well.

    The map() function uses integer math so will not generate fractions, when the math might indicate that
    it should do so. Fractional remainders are truncated, and are not rounded or averaged.
}
  outValue := (inValue - inMin) * (outMax - outMin) / (inMax - inMin) + outMin

CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2022 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
