'' =================================================================================================
''
''   File....... jm_nstr.spin2
''   Purpose.... Convert numbers to strings
''   Authors.... Jon McPhalen
''               -- Copyright (c) 2020 Jon McPhalen
''               -- see below for terms of use
''   E-mail..... jon.mcphalen@gmail.com
''   Started....
''   Updated.... 28 JUN 2020
''
'' =================================================================================================


con

  NBUF_SIZE = 33
  PBUF_SIZE = 81


var

  byte  nbuf[NBUF_SIZE]                                         ' number conversions
  byte  pbuf[PBUF_SIZE]                                         ' padded strings


pub null()

'' This is not a top level object


pub fmt_number(value, radix, digits, width, pad) : p_str

'' Return pointer to string of value converted to number in padded field
'' -- value is converted using radix
'' -- digits is max number of digits to use
'' -- width is width of final fields (max)
'' -- pad is character used to pad final field (if needed)

  case_fast radix
    02    : p_str := padstr(itoa(value,  2, digits), width, pad)
    04    : p_str := padstr(itoa(value,  4, digits), width, pad)
    08    : p_str := padstr(itoa(value,  8, digits), width, pad)
    10    : p_str := padstr(itoa(value, 10, digits), width, pad)
    16    : p_str := padstr(itoa(value, 16, digits), width, pad)

    99    : p_str := padstr(dpdec(value, digits), width, pad)   ' special case

    other : p_str := string("?")


pub dec(value, digits) : p_str | sign, len

'' Convert decimal value to string
'' -- digits is 0 (auto size) to 10

  p_str := itoa(value, 10, digits)


pub dpdec(value, dp) : p_str | len, byte scratch[12]

'' Convert value to string with decimal point
'' -- dp is digits after decimal point
'' -- returns pointer to updated fp string
'' -- modifies original string
'' -- return pointer to converted string

  p_str := itoa(value, 10, 0)

  if (dp <= 0)                                                  ' abort if no decimal point
    return p_str

  len := strsize(p_str)                                         ' digits
  bytefill(@scratch, 0, 12)                                     ' clear scratch buffer

  if (value < 0)                                                ' ignore "-" if present
    ++p_str
    --len

  if (len < (dp+1))                                             ' insert 0s?
    bytemove(@scratch, p_str, len)                              ' move digits to scratch buffer
    bytefill(p_str, "0", dp+2-len)                              ' pad string with 0s
    bytemove(p_str+dp+2-len, @scratch, len+1)                   ' move digits back
    byte[p_str+1] := "."                                        ' insert dpoint
  else
    bytemove(@scratch, p_str+len-dp, dp)                        ' move decimal part to buffer
    byte[p_str+len-dp] := "."                                   ' insert dpoint
    bytemove(p_str+len-dp+1, @scratch, dp+1)                    ' move decimal part back

  if (value < 0)                                                ' fix pointer for negative #s
    --p_str


pub itoa(value, radix, digits) : p_str | sign, len, d

'' Convert integer to string
'' -- supports radix 10, 2, 4, 8, and 16
'' -- digits is 0 (auto size) to limit for long using radix

  bytefill(@nbuf, 0, NBUF_SIZE)                                 ' clear buffer
  p_str := @nbuf                                                ' point to it

  case radix                                                    ' fix digits
    02    : digits := 0 #> digits <# 32
    04    : digits := 0 #> digits <# 16
    08    : digits := 0 #> digits <# 11
    10    : digits := 0 #> digits <# 10
    16    : digits := 0 #> digits <#  8
    other :
      byte[p_str] := 0
      return

  if ((radix == 10) && (value < 0))                             ' deal with negative decimals
    if (value == negx)
      sign := 2
      value := posx
    else
      sign := 1
      value := -value
  else
    sign := 0

  len := 0

  repeat
    d := value +// radix                                        ' get digit (1s column)
    byte[p_str++] := (d < 10) ? d + "0" : d - 10 + "A"          ' convert to ASCII
    value +/= radix                                             ' remove digit
    if (digits)                                                 ' length limited?
      if (++len == digits)                                      '  check size
        quit
    else
      if (value == 0)                                           ' done?
        quit

  if (sign)
    byte[p_str++] := "-"                                        ' add sign if needed
    if (sign == 2)
      nbuf[0] := "8"                                            ' fix negx if needed

  byte[p_str++] := 0                                            ' terminate string

  return revstr(@nbuf)                                          ' fix order (reverse)


pub revstr(p_str) : result | first, len, last

'' Reverse the order of characters in a string.

  result := first := p_str                                      ' start
  len := strsize(p_str)                                         ' length
  last := first + len - 1                                       ' end

  repeat (len >> 1)                                             ' reverse them
    byte[first++], byte[last--] := byte[last], byte[first]


pub padstr(p_str, width, padchar) : p_pad | len

'' Pad string with padchar character
'' -- positive width uses left pad, negative field width uses right pad
'' -- truncate if string len > width
'' -- input string is not modified
'' -- returns pointer to padded string

  bytefill(@pbuf, 0, PBUF_SIZE)                                 ' clear padded buffer
  len := strsize(p_str)                                         ' get length of input
  width := -PBUF_SIZE+1 #> width <# PBUF_SIZE-1                 ' constrain to buffer size

  if (width > 0)                                                ' right-justify in padded field
    if (width > len)
      bytefill(@pbuf, padchar, width-len)
      bytemove(@pbuf+width-len, p_str, len)
      p_pad := @pbuf
    else
      bytemove(@pbuf, p_str+len-width, width)                   ' truncate to right-most characters
      p_pad := @pbuf

  elseif (width < 0)                                            ' left-justify in padded field
    width := -width
    if (width > len)
      bytemove(@pbuf, p_str, len)
      bytefill(@pbuf+len, padchar, width-len)
      p_pad := @pbuf
    else
      bytemove(@pbuf, p_str, width)                             ' truncate to leftmost characters
      p_pad := @pbuf

  else
    p_pad := p_str


con { license }

{{

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

}}
